#!/bin/bash

# This script is used to start ZetaClient for the localnet.
# An optional argument can be passed and can have the following value:
# - background: start the ZetaClient in the background, this prevent the image from being stopped
#               when ZetaClient must be restarted.

/usr/sbin/sshd

HOSTNAME=$(hostname)
export ZETACLIENTD_SUPERVISOR_ENABLE_AUTO_DOWNLOAD=true

# Sepolia is used in chain migration tests, this functions set the sepolia endpoint in
# zetaclient_config.json.
set_sepolia_endpoint() {
    jq '.EVMChainConfigs."11155111".Endpoint = "http://eth2:8545"' \
        /root/.zetacored/config/zetaclient_config.json > tmp.json && \
        mv tmp.json /root/.zetacored/config/zetaclient_config.json
}

enable_multiple_calls() {
    jq '.FeatureFlags = {"EnableMultipleCalls": true, "EnableSolanaAddressLookupTable": true}' \
        /root/.zetacored/config/zetaclient_config.json > tmp.json && \
        mv tmp.json /root/.zetacored/config/zetaclient_config.json
}

set_dry_mode() {
    echo "Setting dry mode"
    jq '.ClientMode = 1' \
        /root/.zetacored/config/zetaclient_config.json > tmp.json && \
        mv tmp.json /root/.zetacored/config/zetaclient_config.json
}

set_chaos_mode() {
    if [[ -z $CHAOS_SEED ]]; then
        CHAOS_SEED=0
    fi

    echo "Setting chaos mode (CHAOS_SEED = ${CHAOS_SEED}) (CHAOS_PROFILE = ${CHAOS_PROFILE})"

    jq ".ClientMode = 2 |
        .ChaosSeed = ${CHAOS_SEED} |
        .ChaosProfilePath = \"/root/chaosprofiles/profile${CHAOS_PROFILE}.json\"
    " \
        /root/.zetacored/config/zetaclient_config.json > tmp.json && \
        mv tmp.json /root/.zetacored/config/zetaclient_config.json
}

# Import a relayer private key (e.g. Solana relayer key).
import_relayer_key() {
    local num="$1"

    # Import solana (network=7) relayer private key.
    privkey_solana=$(yq -r ".observer_relayer_accounts.relayer_accounts[${num}].solana_private_key" /root/config.yml)
    zetaclientd relayer import-key --network=7 --private-key="$privkey_solana" --password=pass_relayerkey
}

PREPARAMS_PATH="/root/preparams/${HOSTNAME}.json"
# Skip preparams setup for replacement observer - it will copy from source client later
if [[ -z "$OBSERVER_REPLACE_MODE" ]]; then
    if [[ -n "${ZETACLIENTD_GEN_PREPARAMS}" ]]; then
        if [ ! -f "$PREPARAMS_PATH" ]; then
            zetaclientd gen-pre-params "$PREPARAMS_PATH"
        fi
    else
        echo "Using static preparams"
        cp "/root/static-preparams/${HOSTNAME}.json" "${PREPARAMS_PATH}"
    fi
fi

# Wait for authorized_keys file to exist (generated by zetacore0).
while [ ! -f ~/.ssh/authorized_keys ]; do
    echo "Waiting for authorized_keys file to exist..."
    sleep 1
done

# Wait for zetacore0 block 1 to be available.
while curl -s zetacore0:26657/block?height=1 | jq -e '.error != null' > /dev/null; do
    echo "Waiting for zetacore0 block 1"
    sleep 5
done

# Read HOTKEY_BACKEND env var for hotkey keyring backend and set default to test.
BACKEND="test"
if [ "$HOTKEY_BACKEND" == "file" ]; then
    BACKEND="file"
fi

# The ZetaClient instances created by this script can connect with different ZetaCore instances.
# - "zetaclient-new-validator" connects with "zetacore-new-validator".
# - "zetaclient-dry" connects with "zetacore0".
# - "zetaclientN" connects with "zetacoreN".
if [[ $HOSTNAME == "zetaclient-new-validator" ]]; then
    node="zetacore-new-validator"
elif [[ $HOSTNAME == "zetaclient-dry" ]]; then
    node="zetacore0"
else
    num=$(echo $HOSTNAME | tr -dc '0-9')
    node="zetacore$num"
fi

# If this is the replacement observer client, copy keyring-file, TSS, and preparams from source client
if [[ -n "$OBSERVER_REPLACE_MODE" && -n "$REUSE_TSS_FROM" ]]; then
    timeout_seconds=300  # 5 minutes
    log_interval=30
    echo "Waiting for TSS keyshare on ${REUSE_TSS_FROM} (timeout ${timeout_seconds}s)..."
    start_time=$(date +%s)
    last_log_time=$start_time

    while true; do
        # Consider either the standard local_share.json or any json file under ~/.tss as presence of keyshare
        if ssh -q "${REUSE_TSS_FROM}" 'test -f ~/.tss/local_share.json || ls -1 ~/.tss/*.json >/dev/null 2>&1'; then
            echo "TSS keyshare detected on ${REUSE_TSS_FROM}"
            break
        fi

        now=$(date +%s)
        elapsed=$((now - start_time))

        # Log progress every 30 seconds
        if (( now - last_log_time >= log_interval )); then
            echo "Still waiting for TSS keyshare... (${elapsed}s elapsed, timeout at ${timeout_seconds}s)"
            last_log_time=$now
        fi

        if (( elapsed >= timeout_seconds )); then
            echo "Error: TSS keyshare not found on ${REUSE_TSS_FROM} within ${timeout_seconds} seconds"
            exit 1
        fi
        sleep 5
    done

    echo "Copying keyring-file, TSS, and preparams from ${REUSE_TSS_FROM}"
    mkdir -p ~/.zetacored/keyring-file/
    mkdir -p ~/.tss/
    mkdir -p /root/preparams/

    # Copy keyring-file with error handling
    if ! scp -r "${REUSE_TSS_FROM}":~/.zetacored/keyring-file/* ~/.zetacored/keyring-file/ 2>/dev/null; then
        echo "Error: Failed to copy keyring-file from ${REUSE_TSS_FROM}"
        exit 1
    fi
    echo "Copied keyring-file successfully"

    # Copy TSS files with error handling
    if ! scp -r "${REUSE_TSS_FROM}":~/.tss/* ~/.tss/ 2>/dev/null; then
        echo "Error: Failed to copy TSS files from ${REUSE_TSS_FROM}"
        exit 1
    fi
    echo "Copied TSS files successfully"
    rm -f ~/.tss/address_book.seed

    # Validate preparams file exists and is non-empty on source before copying
    preparams_source="/root/preparams/${REUSE_TSS_FROM}.json"
    echo "Validating preparams file on ${REUSE_TSS_FROM}..."
    if ! ssh -q "${REUSE_TSS_FROM}" "test -s ${preparams_source}"; then
        echo "Error: Preparams file ${preparams_source} not found or empty on ${REUSE_TSS_FROM}"
        exit 1
    fi

    # Copy preparams file with error handling
    if ! scp "${REUSE_TSS_FROM}":"${preparams_source}" "$PREPARAMS_PATH"; then
        echo "Error: Failed to copy preparams file from ${REUSE_TSS_FROM}"
        exit 1
    fi

    # Verify copied preparams file locally
    if [[ ! -s "$PREPARAMS_PATH" ]]; then
        echo "Error: Copied preparams file is missing or empty at $PREPARAMS_PATH"
        exit 1
    fi
    echo "Copied and verified preparams file successfully"
fi

while [ ! -f $HOME/.zetacored/os.json ]; do
    echo "Waiting for zetacore to exchange os.json file..."
    sleep 1
done
operator=$(cat $HOME/.zetacored/os.json | jq '.ObserverAddress' )
operatorAddress=$(echo "$operator" | tr -d '"')
echo "operatorAddress: $operatorAddress"

# Create the path that holds observer relayer private keys (e.g. Solana relayer key).
RELAYER_KEY_PATH="$HOME/.zetacored/relayer-keys"
mkdir -p "${RELAYER_KEY_PATH}"

mkdir -p "$HOME/.tss/"
address_book_path="$HOME/.tss/address_book.seed"
if [[ ! -f "$address_book_path" ]]; then
    zetae2e local get-zetaclient-bootstrap > $address_book_path
fi

MYIP=$(/sbin/ip -o -4 addr list eth0 | awk '{print $4}' | cut -d/ -f1)

echo "Start zetaclientd"

# Skip initialization if the config file already exists (zetaclientd init has already been run).
if [[ $HOSTNAME == "zetaclient0" && ! -f ~/.zetacored/config/zetaclient_config.json ]]; then
    zetaclientd init --zetacore-url zetacore0 --chain-id athens_101-1 \
        --operator "$operatorAddress" --log-format=text --public-ip "$MYIP" \
        --keyring-backend "$BACKEND" --pre-params "$PREPARAMS_PATH"

    # Import relayer private key for zetaclient0.
    import_relayer_key 0

    # Add feature flags to existing config.
    enable_multiple_calls

    # If eth2 is enabled, set the endpoint in the zetaclient_config.json.
    # In this case, the additional EVM is represented with the sepolia chain, and we manually set
    # the eth2 endpoint to the sepolia chain (11155111 -> http://eth2:8545) in
    # /root/.zetacored/config/zetaclient_config.json.
    if host eth2 > /dev/null; then
        echo "enabling additional evm (eth2)"
        set_sepolia_endpoint
    fi
fi

if [[ $HOSTNAME != "zetaclient0" && ! -f ~/.zetacored/config/zetaclient_config.json ]]; then
    zetaclientd init --zetacore-url "$node" --chain-id athens_101-1 \
        --operator "$operatorAddress" --log-format=text --public-dns "$HOSTNAME.com" \
        --keyring-backend "$BACKEND" --pre-params "$PREPARAMS_PATH"

    # zetaclient-dry does not need to import the relayer private key.
    if [[ $HOSTNAME != "zetaclient-dry" ]]; then
        import_relayer_key "${num}"
    fi

    # Add feature flags to existing config.
    enable_multiple_calls

    # Check if the option is additional-evm. If so, the additional EVM is represented with the
    # sepolia chain, we manually set the eth2 endpoint to the sepolia chain
    # (11155111 -> http://eth2:8545) in /root/.zetacored/config/zetaclient_config.json.
    if [[ -n $ADDITIONAL_EVM ]]; then
        set_sepolia_endpoint
    fi
fi

# Merge zetaclient-config-overlay.json into zetaclient_config.json if specified.
if [[ -f /root/zetaclient-config-overlay.json ]]; then
    jq -s '.[0] * .[1]' \
        /root/.zetacored/config/zetaclient_config.json /root/zetaclient-config-overlay.json > /tmp/merged_config.json
    mv /tmp/merged_config.json /root/.zetacored/config/zetaclient_config.json
fi

# Ensure restricted addresses config is initialized to avoid log spam.
echo "[]" > ~/.zetacored/config/zetaclient_restricted_addresses.json

# Set dry mode in the configuration and wait for TSS initialization.
if [[ $HOSTNAME == "zetaclient-dry" ]]; then
    set_dry_mode
    while :; do
        ssh zetacore0 zetacored query observer get-tss-address > /dev/null 2>&1
        [ $? -ne 0 ] || break
        echo "Waiting for TSS..."
        sleep 1
    done
fi

if [[ -n $CHAOS_PROFILE ]]; then
    set_chaos_mode
fi

echo "Running zetaclientd via supervisor"

zetaclientd-supervisor start < /root/password.file
