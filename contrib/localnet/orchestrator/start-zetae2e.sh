#!/bin/bash

# shellcheck disable=SC2317

# The script run the zetae2e CLI to run local end-to-end tests
# First argument is the command to run the local e2e
# A second optional argument can be passed and can have the following value:
# upgrade: run the local e2e once, then restart zetaclientd at upgrade height and run the local e2e again

# Trap signals and forward to children
trap 'kill -- -$$' SIGINT SIGTERM

/usr/sbin/sshd

# Copy the operator keys from the zetacore nodes to the orchestrator
copy_operator_keys() {
  local nodes=("zetacore0" "zetacore1" "zetacore2" "zetacore3" "zetacore-new-validator")

  for node in "${nodes[@]}"; do
    # Skip if key not available
    ssh -q root@$node "exit" 2>/dev/null || continue
    ssh root@$node "test -d /root/.zetacored/keyring-test/" || continue

    mkdir -p /root/$node/
    scp -r root@$node:/root/.zetacored/keyring-test/ /root/$node/keyring-test/ || continue
    mkdir -p /root/$node/config
    scp root@$node:/root/.zetacored/config/client.toml /root/$node/config/client.toml

    # Set node ID suffix
    node_num=${node//[^0-9]/}
    node_id=${node_num:-"-new-validator"}

    # Rename and copy keys
    zetacored keys rename operator operator$node_id --home=/root/$node/ --keyring-backend=test --yes
    cp -r /root/$node/keyring-test/* /root/.zetacored/keyring-test/
  done

  echo "Key copying process completed"
}

# Copy the genesis file from zetacore0 to the orchestrator
copy_genesis_file() {
  local source_node="zetacore0"
  local source_path="/root/.zetacored/config/genesis.json"
  local dest_dir="/root/.zetacored/data"
  local dest_path="$dest_dir/genesis.json"

  # Check if source node is accessible
  if ! ssh -q root@$source_node "exit" 2>/dev/null; then
    echo "Error: Cannot connect to $source_node"
    return 1
  fi

  # Check if genesis file exists on source node
  if ! ssh root@$source_node "test -f $source_path"; then
    echo "Error: Genesis file not found at $source_path on $source_node"
    return 1
  fi

  # Create destination directory if it doesn't exist
  mkdir -p "$dest_dir"

  # Copy the genesis file
  if scp root@$source_node:$source_path "$dest_path"; then
    echo "Genesis file successfully copied from $source_node to $dest_path"
  else
    echo "Error: Failed to copy genesis file from $source_node"
    return 1
  fi
}

get_zetacored_version() {
  retries=10
  node_info=""
  for ((attempt=1; attempt<=$retries; attempt++)); do
    node_info=$(curl -s -f zetacore0:1317/cosmos/base/tendermint/v1beta1/node_info)
    if [[ $? == 0 ]]; then
      version=$(echo "$node_info" | jq -r '.application_version.version')
      # only return versions containing dots to avoid empty strings and "null"
      if [[ "$version" == *.* ]]; then
        echo "$version"
        return
      fi
    fi
    sleep 1
  done
  echo "Unable to get zetacored version after ${retries} retries"
  exit 1
}

# Reads unquoted string value from config by its path
# Usage: config_str <path>
config_str() {
    yq -r "$1" config.yml
}

# Sends Ether to the given address on Ethereum localnet
# Usage: fund_eth <address> <ether> [comment]
fund_eth() {
    local address=$1
    local ether=$2
    local comment=${3:-}

    if [ -z "$comment" ]; then
        echo "funding eth address $address with $ether eth"
    else
        echo "funding eth address $address ($comment) with $ether eth"
    fi

    geth --exec \
        "eth.sendTransaction({from: eth.accounts[0], to: '${address}', value: web3.toWei(${ether}, 'ether')})" \
        attach http://eth:8545 > /dev/null;
}

# Combines fund_eth with config_str
# Usage: fund_eth_from_config <config-key> <ether> [comment]
fund_eth_from_config() {
    local config_key=$1
    local ether=$2
    local comment=${3:-}

    # Fetch the address from the config file using config_str
    # shellcheck disable=SC2155
    local address=$(config_str "$config_key")
    if [ -z "$address" ]; then
        echo "Error: Address not found for key $config_key"
        return 1
    fi

    # Call fund_eth with the fetched address, ether amount, and optional comment
    fund_eth "$address" "$ether" "$comment"
}

[[ -n $CI ]] && echo "::group::preflight"

# Wait for authorized_keys file to exist (generated by zetacore0)
while [ ! -f ~/.ssh/authorized_keys ]; do
    echo "Waiting for authorized_keys file to exist..."
    sleep 1
done

# need to wait for zetacore0 to be up
while ! curl -s -o /dev/null zetacore0:26657/status ; do
    echo "Waiting for zetacore0 rpc"
    sleep 10
done

echo "waiting for geth RPC to start..."
sleep 2

### Create the accounts and fund them with Ether on local Ethereum network

# unlock the default account account
fund_eth_from_config '.default_account.evm_address' 10000 "deployer"

# unlock legacy erc20 tester accounts
fund_eth_from_config '.additional_accounts.user_legacy_erc20.evm_address' 10000 "ERC20 tester"

# unlock legacy zeta tester accounts
fund_eth_from_config '.additional_accounts.user_legacy_zeta.evm_address' 10000 "zeta tester"

# unlock legacy zevm message passing tester accounts
fund_eth_from_config '.additional_accounts.user_legacy_zevm_mp.evm_address' 10000 "zevm mp tester"

# unlock legacy ethers tester accounts
fund_eth_from_config '.additional_accounts.user_legacy_ether.evm_address' 10000 "ether tester"

# unlock bitcoin deposit tester accounts
fund_eth_from_config '.additional_accounts.user_bitcoin_deposit.evm_address' 10000 "bitcoin deposit tester"

# unlock bitcoin withdraw tester accounts
fund_eth_from_config '.additional_accounts.user_bitcoin_withdraw.evm_address' 10000 "bitcoin withdraw tester"

# unlock solana tester accounts
fund_eth_from_config '.additional_accounts.user_solana.evm_address' 10000 "solana tester"

# unlock ton tester accounts
fund_eth_from_config '.additional_accounts.user_ton.evm_address' 10000 "ton tester"

# unlock sui tester accounts
fund_eth_from_config '.additional_accounts.user_sui.evm_address' 10000 "sui tester"

# unlock miscellaneous tests accounts
fund_eth_from_config '.additional_accounts.user_misc.evm_address' 10000 "misc tester"

# unlock admin erc20 tests accounts
fund_eth_from_config '.additional_accounts.user_admin.evm_address' 10000 "admin tester"

# unlock migration tests accounts
fund_eth_from_config '.additional_accounts.user_migration.evm_address' 10000 "migration tester"

# unlock ethers tests accounts
fund_eth_from_config '.additional_accounts.user_ether.evm_address' 10000  "V2 ethers tester"

# unlock erc20 tests accounts
fund_eth_from_config '.additional_accounts.user_erc20.evm_address' 10000  "V2 ERC20 tester"

# unlock ethers revert tests accounts
fund_eth_from_config '.additional_accounts.user_ether_revert.evm_address' 10000 "V2 ethers revert tester"

# unlock erc20 revert tests accounts
fund_eth_from_config '.additional_accounts.user_erc20_revert.evm_address' 10000 "V2 ERC20 revert tester"

# unlock zeta tests accounts
fund_eth_from_config '.additional_accounts.user_zeta.evm_address' 10000 "V2 zeta tester"

# unlock emissions withdraw tests accounts
fund_eth_from_config '.additional_accounts.user_emissions_withdraw.evm_address' 10000 "emissions withdraw tester"

# Create the destination directory
mkdir -p /root/.zetacored/keyring-test/
# Copy the keys from the localnet directory to the keyring-test directory
copy_operator_keys
copy_genesis_file

# unlock local solana relayer accounts
if host solana > /dev/null; then
  solana_url=$(config_str '.rpcs.solana')
  solana config set --url "$solana_url" > /dev/null

  relayer=$(config_str '.observer_relayer_accounts.relayer_accounts[0].solana_address')
  echo "funding solana relayer address ${relayer} with 100 SOL"
  solana airdrop 100 "$relayer" > /dev/null

  relayer=$(config_str '.observer_relayer_accounts.relayer_accounts[1].solana_address')
  echo "funding solana relayer address ${relayer} with 100 SOL"
  solana airdrop 100 "$relayer" > /dev/null
fi

# Wait for TON node to bootstrap
if host ton > /dev/null; then
  ./wait-for-ton.sh
fi

[[ -n $CI ]] && echo -e "\n::endgroup::"

# need to make the directory if it was not mounted as a volume
mkdir -p /root/state
deployed_config_path=/root/state/deployed.yml

### Run zetae2e command depending on the option passed
ACCOUNT_CONFIG="/work/config.yml"
export OLD_VERSION=$(get_zetacored_version)
# Mode migrate is used to run the e2e tests before and after the TSS migration
# It runs the e2e tests with the migrate flag which triggers a TSS migration at the end of the tests. Once the migrationis done the first e2e test is complete
# The second e2e test is run after the migration to ensure the network is still working as expected with the new tss address
if [ "$LOCALNET_MODE" == "tss-migrate" ]; then
  if [[ ! -f "$deployed_config_path" ]]; then
    [[ -n $CI ]] && echo "::group::setup"
    zetae2e local $E2E_ARGS --setup-only --config config.yml --config-out "$deployed_config_path" --skip-header-proof
    if [ $? -ne 0 ]; then
      echo "E2E setup failed"
      exit 1
    fi
    [[ -n $CI ]] && echo -e "\n::endgroup::"
  else
    echo "Skipping E2E setup because it has already been completed"
  fi

  echo "Running E2E test before migrating TSS"
  zetae2e local $E2E_ARGS --skip-setup --config "$deployed_config_path"  --skip-header-proof --light --test-tss-migration
  if [ $? -ne 0 ]; then
    echo "First E2E failed"
    exit 1
  fi

  echo "Waiting 10 seconds for node to restart"
  sleep 10

  zetae2e local $E2E_ARGS --skip-setup --config "$deployed_config_path" --account-config "$ACCOUNT_CONFIG" --skip-bitcoin-setup --light --skip-header-proof

  ZETAE2E_EXIT_CODE=$?
  if [ $ZETAE2E_EXIT_CODE -eq 0 ]; then
    echo "E2E passed after migration"
    exit 0
  fi

  echo "E2E failed after migration"
  exit 1
fi

# Mode `upgrade` is used to run the E2E before and after chain upgrade. Flow:
# 1. Setup e2e and run tests (optionally using the prev. zetae2e)
# 2. Wait for upgrade height to be reached 
#  - cosmovisor will restart zetaclientd;
#  - zetaclient-supervisor will download the new version of zetaclientd
# 3. Run e2e tests again
if [ "$LOCALNET_MODE" == "upgrade" ]; then
  # set upgrade height to 225 by default
  UPGRADE_HEIGHT=${UPGRADE_HEIGHT:=225}
  # shellcheck disable=SC2155
  COMMON_ARGS="--skip-header-proof --skip-tracker-check"
  USE_ZETAE2E_ANTE=${USE_ZETAE2E_ANTE:=false}

  # if enabled, fetches zetae2e binary from the previous version
  # ante means "before" in Latin (used in Cosmos terminology)
  if [ "$USE_ZETAE2E_ANTE" = true ]; then
    echo "zetae2e-ante: using the PREVIOUS binary ($OLD_VERSION)"
    scp root@zetacore0:/usr/local/bin/zetae2e /usr/local/bin/zetae2e-ante
    chmod +x /usr/local/bin/zetae2e-ante
  else
    echo "zetae2e-ante: using the LATEST binary"
    ln -sf "$(command -v zetae2e)" /usr/local/bin/zetae2e-ante
  fi

  if [[ ! -f "$deployed_config_path"  ]]; then
    [[ -n $CI ]] && echo "::group::setup"
    echo "Running E2E setup..."
    zetae2e-ante local $E2E_ARGS --setup-only --config config.yml --config-out "$deployed_config_path" ${COMMON_ARGS}
    if [ $? -ne 0 ]; then
      echo "E2E setup failed"
      exit 1
    fi
    [[ -n $CI ]] && echo -e "\n::endgroup::"
  else
    echo "Skipping E2E setup because it has already been completed"
  fi

  # Run zetae2e, if the upgrade height is greater than 100 to populate the state
  if [ "$UPGRADE_HEIGHT" -gt 100 ]; then
    echo "Running E2E command to setup the networks and populate the state..."

    # Use light flag to ensure tests can complete before the upgrade height
    # skip-bitcoin-dust-withdraw flag can be removed after v23 is released
    zetae2e-ante local $E2E_ARGS --skip-setup --config "$deployed_config_path" --light ${COMMON_ARGS}
    if [ $? -ne 0 ]; then
      echo "First E2E failed"
      exit 1
    fi
  fi

  echo "Waiting for upgrade height..."
  CURRENT_HEIGHT=0
  WAIT_HEIGHT=$(( UPGRADE_HEIGHT - 1 ))
  # wait for upgrade height
  while [[ $CURRENT_HEIGHT -lt $WAIT_HEIGHT ]]
  do
    CURRENT_HEIGHT=$(curl -s zetacore0:26657/status | jq -r '.result.sync_info.latest_block_height')
    echo Current height is "$CURRENT_HEIGHT", waiting for "$WAIT_HEIGHT"
    sleep 2
  done

  echo "Waiting 10 seconds for node to restart..."
  sleep 10

  NEW_VERSION=$(get_zetacored_version)

  echo "Upgrade result: ${OLD_VERSION} -> ${NEW_VERSION}"

  if [[ "$OLD_VERSION" == "$NEW_VERSION" ]]; then
    echo "Version did not change after upgrade height, maybe the upgrade did not run?"
    exit 2
  fi

  # wait for zevm endpoint to come up
  sleep 10
  echo "Running E2E command to test the network after upgrade..."

  # Run zetae2e again
  # When the upgrade height is greater than 100 for upgrade test, the Bitcoin tests have been run once, therefore the Bitcoin wallet is already set up
  # Use light flag to skip advanced tests

  if [ "$UPGRADE_HEIGHT" -lt 100 ]; then
    zetae2e local $E2E_ARGS --skip-setup --config "$deployed_config_path" --account-config "$ACCOUNT_CONFIG" --light ${COMMON_ARGS}
  else
    zetae2e local $E2E_ARGS --skip-setup --config "$deployed_config_path" --account-config "$ACCOUNT_CONFIG" --skip-bitcoin-setup --light ${COMMON_ARGS}
  fi

  ZETAE2E_EXIT_CODE=$?
  if [ $ZETAE2E_EXIT_CODE -eq 0 ]; then
    echo "E2E passed after upgrade"
    exit 0
  fi

  echo "E2E failed after upgrade"
  exit 1
fi

# No mode is passed, run the e2e tests normally

if [[ ! -f "$deployed_config_path"  ]]; then
  [[ -n $CI ]] && echo "::group::setup"
  echo "Running E2E setup..."
  zetae2e local $E2E_ARGS --config config.yml --setup-only --config-out "$deployed_config_path"
  if [ $? -ne 0 ]; then
    echo "e2e setup failed"
    exit 1
  fi
  [[ -n $CI ]] && echo -e "\n::endgroup::"
else
  echo "Skipping E2E setup because it has already been completed"
fi

if [ "$LOCALNET_MODE" == "setup-only" ]; then
  exit 0
fi

echo "Running e2e tests with arguments: $E2E_ARGS"

zetae2e local $E2E_ARGS --skip-setup --config "$deployed_config_path"
ZETAE2E_EXIT_CODE=$?

# if e2e passed, exit with 0, otherwise exit with 1
if [ $ZETAE2E_EXIT_CODE -eq 0 ]; then
  echo "E2E passed"
  exit 0
fi

echo "E2E failed"
exit 1

