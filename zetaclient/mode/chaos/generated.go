// Code generated by zetaclient/mode/chaos/generate. DO NOT EDIT.
package chaos

import (
	m2 "context"
	m28 "github.com/block-vision/sui-go-sdk/models"
	m13 "github.com/btcsuite/btcd/btcjson"
	m17 "github.com/btcsuite/btcd/btcutil"
	m14 "github.com/btcsuite/btcd/chaincfg/chainhash"
	m15 "github.com/btcsuite/btcd/wire"
	m8 "github.com/cometbft/cometbft/types"
	m11 "github.com/cosmos/cosmos-sdk/types"
	m22 "github.com/ethereum/go-ethereum"
	m5 "github.com/ethereum/go-ethereum/common"
	m23 "github.com/ethereum/go-ethereum/core/types"
	m25 "github.com/gagliardetto/solana-go"
	m26 "github.com/gagliardetto/solana-go/rpc"
	m29 "github.com/pattonkan/sui-go/sui"
	m34 "github.com/tonkeeper/tongo/boc"
	m32 "github.com/tonkeeper/tongo/ton"
	m9 "github.com/zeta-chain/go-tss/blame"
	m1 "github.com/zeta-chain/node/pkg/chains"
	m10 "github.com/zeta-chain/node/pkg/errors"
	m4 "github.com/zeta-chain/node/x/crosschain/types"
	m6 "github.com/zeta-chain/node/x/fungible/types"
	m3 "github.com/zeta-chain/node/x/observer/types"
	m12 "github.com/zeta-chain/node/zetaclient/chains/bitcoin"
	m16 "github.com/zeta-chain/node/zetaclient/chains/bitcoin/client"
	m19 "github.com/zeta-chain/node/zetaclient/chains/evm"
	m21 "github.com/zeta-chain/node/zetaclient/chains/evm/client"
	m24 "github.com/zeta-chain/node/zetaclient/chains/solana"
	m27 "github.com/zeta-chain/node/zetaclient/chains/sui"
	m30 "github.com/zeta-chain/node/zetaclient/chains/sui/client"
	m31 "github.com/zeta-chain/node/zetaclient/chains/ton"
	m33 "github.com/zeta-chain/node/zetaclient/chains/ton/rpc"
	m35 "github.com/zeta-chain/node/zetaclient/chains/tssrepo"
	m0 "github.com/zeta-chain/node/zetaclient/chains/zrepo"
	m7 "github.com/zeta-chain/node/zetaclient/keys/interfaces"
	m36 "github.com/zeta-chain/node/zetaclient/tss"
	m20 "math/big"
	m18 "time"
)

// ------------------------------------------------------------------------------------------------
// ZetacoreClient
// ------------------------------------------------------------------------------------------------

type chaosZetacoreClient struct {
	*Source
	client m0.ZetacoreClient
}

// If you are getting a error in this line you should probably run "make generate".
var _ m0.ZetacoreClient = &chaosZetacoreClient{}

func (source *Source) WrapZetacoreClient(client m0.ZetacoreClient) *chaosZetacoreClient {
	return &chaosZetacoreClient{Source: source, client: client}
}

func (self *chaosZetacoreClient) Chain() (
	out0 m1.Chain,
) {
	// Functions that do not return errors cannot fail.
	return self.client.Chain()
}

func (self *chaosZetacoreClient) GetBTCTSSAddress(
	in0 m2.Context,
	in1 int64,
) (
	out0 string,
	out1 error,
) {
	if err := self.shouldFail("ZetacoreClient", "GetBTCTSSAddress"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetBTCTSSAddress(in0, in1)
	}
	return
}

func (self *chaosZetacoreClient) GetBallotByID(
	in0 m2.Context,
	in1 string,
) (
	out0 *m3.QueryBallotByIdentifierResponse,
	out1 error,
) {
	if err := self.shouldFail("ZetacoreClient", "GetBallotByID"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetBallotByID(in0, in1)
	}
	return
}

func (self *chaosZetacoreClient) GetBlockHeight(
	in0 m2.Context,
) (
	out0 int64,
	out1 error,
) {
	if err := self.shouldFail("ZetacoreClient", "GetBlockHeight"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetBlockHeight(in0)
	}
	return
}

func (self *chaosZetacoreClient) GetCctxByHash(
	in0 m2.Context,
	in1 string,
) (
	out0 *m4.CrossChainTx,
	out1 error,
) {
	if err := self.shouldFail("ZetacoreClient", "GetCctxByHash"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetCctxByHash(in0, in1)
	}
	return
}

func (self *chaosZetacoreClient) GetCctxByNonce(
	in0 m2.Context,
	in1 int64,
	in2 uint64,
) (
	out0 *m4.CrossChainTx,
	out1 error,
) {
	if err := self.shouldFail("ZetacoreClient", "GetCctxByNonce"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetCctxByNonce(in0, in1, in2)
	}
	return
}

func (self *chaosZetacoreClient) GetForeignCoinsFromAsset(
	in0 m2.Context,
	in1 int64,
	in2 m5.Address,
) (
	out0 m6.ForeignCoins,
	out1 error,
) {
	if err := self.shouldFail("ZetacoreClient", "GetForeignCoinsFromAsset"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetForeignCoinsFromAsset(in0, in1, in2)
	}
	return
}

func (self *chaosZetacoreClient) GetInboundTrackersForChain(
	in0 m2.Context,
	in1 int64,
) (
	out0 []m4.InboundTracker,
	out1 error,
) {
	if err := self.shouldFail("ZetacoreClient", "GetInboundTrackersForChain"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetInboundTrackersForChain(in0, in1)
	}
	return
}

func (self *chaosZetacoreClient) GetKeys() (
	out0 m7.ObserverKeys,
) {
	// Functions that do not return errors cannot fail.
	return self.client.GetKeys()
}

func (self *chaosZetacoreClient) GetOutboundTracker(
	in0 m2.Context,
	in1 int64,
	in2 uint64,
) (
	out0 *m4.OutboundTracker,
	out1 error,
) {
	if err := self.shouldFail("ZetacoreClient", "GetOutboundTracker"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetOutboundTracker(in0, in1, in2)
	}
	return
}

func (self *chaosZetacoreClient) GetOutboundTrackers(
	in0 m2.Context,
	in1 int64,
) (
	out0 []m4.OutboundTracker,
	out1 error,
) {
	if err := self.shouldFail("ZetacoreClient", "GetOutboundTrackers"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetOutboundTrackers(in0, in1)
	}
	return
}

func (self *chaosZetacoreClient) GetPendingNoncesByChain(
	in0 m2.Context,
	in1 int64,
) (
	out0 m3.PendingNonces,
	out1 error,
) {
	if err := self.shouldFail("ZetacoreClient", "GetPendingNoncesByChain"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetPendingNoncesByChain(in0, in1)
	}
	return
}

func (self *chaosZetacoreClient) HasVoted(
	in0 m2.Context,
	in1 string,
	in2 string,
) (
	out0 bool,
	out1 error,
) {
	if err := self.shouldFail("ZetacoreClient", "HasVoted"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.HasVoted(in0, in1, in2)
	}
	return
}

func (self *chaosZetacoreClient) ListPendingCCTX(
	in0 m2.Context,
	in1 m1.Chain,
) (
	out0 []*m4.CrossChainTx,
	out1 uint64,
	out2 error,
) {
	if err := self.shouldFail("ZetacoreClient", "ListPendingCCTX"); err != nil {
		out2 = err
	} else {
		out0, out1, out2 = self.client.ListPendingCCTX(in0, in1)
	}
	return
}

func (self *chaosZetacoreClient) NewBlockSubscriber(
	in0 m2.Context,
) (
	out0 chan m8.EventDataNewBlock,
	out1 error,
) {
	if err := self.shouldFail("ZetacoreClient", "NewBlockSubscriber"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.NewBlockSubscriber(in0)
	}
	return
}

func (self *chaosZetacoreClient) PostOutboundTracker(
	in0 m2.Context,
	in1 int64,
	in2 uint64,
	in3 string,
) (
	out0 string,
	out1 error,
) {
	if err := self.shouldFail("ZetacoreClient", "PostOutboundTracker"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.PostOutboundTracker(in0, in1, in2, in3)
	}
	return
}

func (self *chaosZetacoreClient) PostVoteBlameData(
	in0 m2.Context,
	in1 *m9.Blame,
	in2 int64,
	in3 string,
) (
	out0 string,
	out1 error,
) {
	if err := self.shouldFail("ZetacoreClient", "PostVoteBlameData"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.PostVoteBlameData(in0, in1, in2, in3)
	}
	return
}

func (self *chaosZetacoreClient) PostVoteGasPrice(
	in0 m2.Context,
	in1 m1.Chain,
	in2 uint64,
	in3 uint64,
	in4 uint64,
) (
	out0 string,
	out1 error,
) {
	if err := self.shouldFail("ZetacoreClient", "PostVoteGasPrice"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.PostVoteGasPrice(in0, in1, in2, in3, in4)
	}
	return
}

func (self *chaosZetacoreClient) PostVoteInbound(
	in0 m2.Context,
	in1 uint64,
	in2 uint64,
	in3 *m4.MsgVoteInbound,
	in4 chan<- m10.ErrTxMonitor,
) (
	out0 string,
	out1 string,
	out2 error,
) {
	if err := self.shouldFail("ZetacoreClient", "PostVoteInbound"); err != nil {
		out2 = err
	} else {
		out0, out1, out2 = self.client.PostVoteInbound(in0, in1, in2, in3, in4)
	}
	return
}

func (self *chaosZetacoreClient) PostVoteOutbound(
	in0 m2.Context,
	in1 uint64,
	in2 uint64,
	in3 *m4.MsgVoteOutbound,
) (
	out0 string,
	out1 string,
	out2 error,
) {
	if err := self.shouldFail("ZetacoreClient", "PostVoteOutbound"); err != nil {
		out2 = err
	} else {
		out0, out1, out2 = self.client.PostVoteOutbound(in0, in1, in2, in3)
	}
	return
}

func (self *chaosZetacoreClient) PostVoteTSS(
	in0 m2.Context,
	in1 string,
	in2 int64,
	in3 m1.ReceiveStatus,
) (
	out0 string,
	out1 error,
) {
	if err := self.shouldFail("ZetacoreClient", "PostVoteTSS"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.PostVoteTSS(in0, in1, in2, in3)
	}
	return
}

func (self *chaosZetacoreClient) QueryTxResult(
	in0 string,
) (
	out0 *m11.TxResponse,
	out1 error,
) {
	if err := self.shouldFail("ZetacoreClient", "QueryTxResult"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.QueryTxResult(in0)
	}
	return
}

// ------------------------------------------------------------------------------------------------
// BitcoinClient
// ------------------------------------------------------------------------------------------------

type chaosBitcoinClient struct {
	*Source
	client m12.BitcoinClient
}

// If you are getting a error in this line you should probably run "make generate".
var _ m12.BitcoinClient = &chaosBitcoinClient{}

func (source *Source) WrapBitcoinClient(client m12.BitcoinClient) *chaosBitcoinClient {
	return &chaosBitcoinClient{Source: source, client: client}
}

func (self *chaosBitcoinClient) EstimateSmartFee(
	in0 m2.Context,
	in1 int64,
	in2 *m13.EstimateSmartFeeMode,
) (
	out0 *m13.EstimateSmartFeeResult,
	out1 error,
) {
	if err := self.shouldFail("BitcoinClient", "EstimateSmartFee"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.EstimateSmartFee(in0, in1, in2)
	}
	return
}

func (self *chaosBitcoinClient) GetBlockCount(
	in0 m2.Context,
) (
	out0 int64,
	out1 error,
) {
	if err := self.shouldFail("BitcoinClient", "GetBlockCount"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetBlockCount(in0)
	}
	return
}

func (self *chaosBitcoinClient) GetBlockHash(
	in0 m2.Context,
	in1 int64,
) (
	out0 *m14.Hash,
	out1 error,
) {
	if err := self.shouldFail("BitcoinClient", "GetBlockHash"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetBlockHash(in0, in1)
	}
	return
}

func (self *chaosBitcoinClient) GetBlockHeader(
	in0 m2.Context,
	in1 *m14.Hash,
) (
	out0 *m15.BlockHeader,
	out1 error,
) {
	if err := self.shouldFail("BitcoinClient", "GetBlockHeader"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetBlockHeader(in0, in1)
	}
	return
}

func (self *chaosBitcoinClient) GetBlockHeightByStr(
	in0 m2.Context,
	in1 string,
) (
	out0 int64,
	out1 error,
) {
	if err := self.shouldFail("BitcoinClient", "GetBlockHeightByStr"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetBlockHeightByStr(in0, in1)
	}
	return
}

func (self *chaosBitcoinClient) GetBlockVerbose(
	in0 m2.Context,
	in1 *m14.Hash,
) (
	out0 *m13.GetBlockVerboseTxResult,
	out1 error,
) {
	if err := self.shouldFail("BitcoinClient", "GetBlockVerbose"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetBlockVerbose(in0, in1)
	}
	return
}

func (self *chaosBitcoinClient) GetEstimatedFeeRate(
	in0 m2.Context,
	in1 int64,
) (
	out0 uint64,
	out1 error,
) {
	if err := self.shouldFail("BitcoinClient", "GetEstimatedFeeRate"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetEstimatedFeeRate(in0, in1)
	}
	return
}

func (self *chaosBitcoinClient) GetMempoolEntry(
	in0 m2.Context,
	in1 string,
) (
	out0 *m13.GetMempoolEntryResult,
	out1 error,
) {
	if err := self.shouldFail("BitcoinClient", "GetMempoolEntry"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetMempoolEntry(in0, in1)
	}
	return
}

func (self *chaosBitcoinClient) GetMempoolTxsAndFees(
	in0 m2.Context,
	in1 string,
) (
	out0 m16.MempoolTxsAndFees,
	out1 error,
) {
	if err := self.shouldFail("BitcoinClient", "GetMempoolTxsAndFees"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetMempoolTxsAndFees(in0, in1)
	}
	return
}

func (self *chaosBitcoinClient) GetNetworkInfo(
	in0 m2.Context,
) (
	out0 *m13.GetNetworkInfoResult,
	out1 error,
) {
	if err := self.shouldFail("BitcoinClient", "GetNetworkInfo"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetNetworkInfo(in0)
	}
	return
}

func (self *chaosBitcoinClient) GetRawTransaction(
	in0 m2.Context,
	in1 *m14.Hash,
) (
	out0 *m17.Tx,
	out1 error,
) {
	if err := self.shouldFail("BitcoinClient", "GetRawTransaction"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetRawTransaction(in0, in1)
	}
	return
}

func (self *chaosBitcoinClient) GetRawTransactionByStr(
	in0 m2.Context,
	in1 string,
) (
	out0 *m17.Tx,
	out1 error,
) {
	if err := self.shouldFail("BitcoinClient", "GetRawTransactionByStr"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetRawTransactionByStr(in0, in1)
	}
	return
}

func (self *chaosBitcoinClient) GetRawTransactionResult(
	in0 m2.Context,
	in1 *m14.Hash,
	in2 *m13.GetTransactionResult,
) (
	out0 m13.TxRawResult,
	out1 error,
) {
	if err := self.shouldFail("BitcoinClient", "GetRawTransactionResult"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetRawTransactionResult(in0, in1, in2)
	}
	return
}

func (self *chaosBitcoinClient) GetRawTransactionVerbose(
	in0 m2.Context,
	in1 *m14.Hash,
) (
	out0 *m13.TxRawResult,
	out1 error,
) {
	if err := self.shouldFail("BitcoinClient", "GetRawTransactionVerbose"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetRawTransactionVerbose(in0, in1)
	}
	return
}

func (self *chaosBitcoinClient) GetTransactionByStr(
	in0 m2.Context,
	in1 string,
) (
	out0 *m14.Hash,
	out1 *m13.GetTransactionResult,
	out2 error,
) {
	if err := self.shouldFail("BitcoinClient", "GetTransactionByStr"); err != nil {
		out2 = err
	} else {
		out0, out1, out2 = self.client.GetTransactionByStr(in0, in1)
	}
	return
}

func (self *chaosBitcoinClient) GetTransactionFeeAndRate(
	in0 m2.Context,
	in1 *m13.TxRawResult,
) (
	out0 int64,
	out1 int64,
	out2 error,
) {
	if err := self.shouldFail("BitcoinClient", "GetTransactionFeeAndRate"); err != nil {
		out2 = err
	} else {
		out0, out1, out2 = self.client.GetTransactionFeeAndRate(in0, in1)
	}
	return
}

func (self *chaosBitcoinClient) GetTransactionInitiator(
	in0 m2.Context,
	in1 string,
) (
	out0 string,
	out1 error,
) {
	if err := self.shouldFail("BitcoinClient", "GetTransactionInitiator"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetTransactionInitiator(in0, in1)
	}
	return
}

func (self *chaosBitcoinClient) GetTransactionInputSpender(
	in0 m2.Context,
	in1 string,
	in2 uint32,
) (
	out0 string,
	out1 error,
) {
	if err := self.shouldFail("BitcoinClient", "GetTransactionInputSpender"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetTransactionInputSpender(in0, in1, in2)
	}
	return
}

func (self *chaosBitcoinClient) Healthcheck(
	in0 m2.Context,
) (
	out0 m18.Time,
	out1 error,
) {
	if err := self.shouldFail("BitcoinClient", "Healthcheck"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.Healthcheck(in0)
	}
	return
}

func (self *chaosBitcoinClient) IsTxStuckInMempool(
	in0 m2.Context,
	in1 string,
	in2 int64,
) (
	out0 bool,
	out1 m18.Duration,
	out2 error,
) {
	if err := self.shouldFail("BitcoinClient", "IsTxStuckInMempool"); err != nil {
		out2 = err
	} else {
		out0, out1, out2 = self.client.IsTxStuckInMempool(in0, in1, in2)
	}
	return
}

func (self *chaosBitcoinClient) ListUnspentMinMaxAddresses(
	in0 m2.Context,
	in1 int,
	in2 int,
	in3 []m17.Address,
) (
	out0 []m13.ListUnspentResult,
	out1 error,
) {
	if err := self.shouldFail("BitcoinClient", "ListUnspentMinMaxAddresses"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.ListUnspentMinMaxAddresses(in0, in1, in2, in3)
	}
	return
}

func (self *chaosBitcoinClient) SendRawTransaction(
	in0 m2.Context,
	in1 *m15.MsgTx,
	in2 bool,
) (
	out0 *m14.Hash,
	out1 error,
) {
	if err := self.shouldFail("BitcoinClient", "SendRawTransaction"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.SendRawTransaction(in0, in1, in2)
	}
	return
}

// ------------------------------------------------------------------------------------------------
// EVMClient
// ------------------------------------------------------------------------------------------------

type chaosEVMClient struct {
	*Source
	client m19.EVMClient
}

// If you are getting a error in this line you should probably run "make generate".
var _ m19.EVMClient = &chaosEVMClient{}

func (source *Source) WrapEVMClient(client m19.EVMClient) *chaosEVMClient {
	return &chaosEVMClient{Source: source, client: client}
}

func (self *chaosEVMClient) BlockByNumberCustom(
	in0 m2.Context,
	in1 *m20.Int,
) (
	out0 *m21.Block,
	out1 error,
) {
	if err := self.shouldFail("EVMClient", "BlockByNumberCustom"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.BlockByNumberCustom(in0, in1)
	}
	return
}

func (self *chaosEVMClient) BlockNumber(
	in0 m2.Context,
) (
	out0 uint64,
	out1 error,
) {
	if err := self.shouldFail("EVMClient", "BlockNumber"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.BlockNumber(in0)
	}
	return
}

func (self *chaosEVMClient) CallContract(
	in0 m2.Context,
	in1 m22.CallMsg,
	in2 *m20.Int,
) (
	out0 []uint8,
	out1 error,
) {
	if err := self.shouldFail("EVMClient", "CallContract"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.CallContract(in0, in1, in2)
	}
	return
}

func (self *chaosEVMClient) CodeAt(
	in0 m2.Context,
	in1 m5.Address,
	in2 *m20.Int,
) (
	out0 []uint8,
	out1 error,
) {
	if err := self.shouldFail("EVMClient", "CodeAt"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.CodeAt(in0, in1, in2)
	}
	return
}

func (self *chaosEVMClient) EstimateGas(
	in0 m2.Context,
	in1 m22.CallMsg,
) (
	out0 uint64,
	out1 error,
) {
	if err := self.shouldFail("EVMClient", "EstimateGas"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.EstimateGas(in0, in1)
	}
	return
}

func (self *chaosEVMClient) FilterLogs(
	in0 m2.Context,
	in1 m22.FilterQuery,
) (
	out0 []m23.Log,
	out1 error,
) {
	if err := self.shouldFail("EVMClient", "FilterLogs"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.FilterLogs(in0, in1)
	}
	return
}

func (self *chaosEVMClient) HeaderByNumber(
	in0 m2.Context,
	in1 *m20.Int,
) (
	out0 *m23.Header,
	out1 error,
) {
	if err := self.shouldFail("EVMClient", "HeaderByNumber"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.HeaderByNumber(in0, in1)
	}
	return
}

func (self *chaosEVMClient) HealthCheck(
	in0 m2.Context,
) (
	out0 m18.Time,
	out1 error,
) {
	if err := self.shouldFail("EVMClient", "HealthCheck"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.HealthCheck(in0)
	}
	return
}

func (self *chaosEVMClient) IsTxConfirmed(
	in0 m2.Context,
	in1 string,
	in2 uint64,
) (
	out0 bool,
	out1 error,
) {
	if err := self.shouldFail("EVMClient", "IsTxConfirmed"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.IsTxConfirmed(in0, in1, in2)
	}
	return
}

func (self *chaosEVMClient) NonceAt(
	in0 m2.Context,
	in1 m5.Address,
	in2 *m20.Int,
) (
	out0 uint64,
	out1 error,
) {
	if err := self.shouldFail("EVMClient", "NonceAt"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.NonceAt(in0, in1, in2)
	}
	return
}

func (self *chaosEVMClient) PendingCodeAt(
	in0 m2.Context,
	in1 m5.Address,
) (
	out0 []uint8,
	out1 error,
) {
	if err := self.shouldFail("EVMClient", "PendingCodeAt"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.PendingCodeAt(in0, in1)
	}
	return
}

func (self *chaosEVMClient) PendingNonceAt(
	in0 m2.Context,
	in1 m5.Address,
) (
	out0 uint64,
	out1 error,
) {
	if err := self.shouldFail("EVMClient", "PendingNonceAt"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.PendingNonceAt(in0, in1)
	}
	return
}

func (self *chaosEVMClient) SendTransaction(
	in0 m2.Context,
	in1 *m23.Transaction,
) (
	out0 error,
) {
	if err := self.shouldFail("EVMClient", "SendTransaction"); err != nil {
		out0 = err
	} else {
		out0 = self.client.SendTransaction(in0, in1)
	}
	return
}

func (self *chaosEVMClient) Signer() (
	out0 m23.Signer,
) {
	// Functions that do not return errors cannot fail.
	return self.client.Signer()
}

func (self *chaosEVMClient) SubscribeFilterLogs(
	in0 m2.Context,
	in1 m22.FilterQuery,
	in2 chan<- m23.Log,
) (
	out0 m22.Subscription,
	out1 error,
) {
	if err := self.shouldFail("EVMClient", "SubscribeFilterLogs"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.SubscribeFilterLogs(in0, in1, in2)
	}
	return
}

func (self *chaosEVMClient) SuggestGasPrice(
	in0 m2.Context,
) (
	out0 *m20.Int,
	out1 error,
) {
	if err := self.shouldFail("EVMClient", "SuggestGasPrice"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.SuggestGasPrice(in0)
	}
	return
}

func (self *chaosEVMClient) SuggestGasTipCap(
	in0 m2.Context,
) (
	out0 *m20.Int,
	out1 error,
) {
	if err := self.shouldFail("EVMClient", "SuggestGasTipCap"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.SuggestGasTipCap(in0)
	}
	return
}

func (self *chaosEVMClient) TransactionByHash(
	in0 m2.Context,
	in1 m5.Hash,
) (
	out0 *m23.Transaction,
	out1 bool,
	out2 error,
) {
	if err := self.shouldFail("EVMClient", "TransactionByHash"); err != nil {
		out2 = err
	} else {
		out0, out1, out2 = self.client.TransactionByHash(in0, in1)
	}
	return
}

func (self *chaosEVMClient) TransactionByHashCustom(
	in0 m2.Context,
	in1 string,
) (
	out0 *m21.Transaction,
	out1 error,
) {
	if err := self.shouldFail("EVMClient", "TransactionByHashCustom"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.TransactionByHashCustom(in0, in1)
	}
	return
}

func (self *chaosEVMClient) TransactionReceipt(
	in0 m2.Context,
	in1 m5.Hash,
) (
	out0 *m23.Receipt,
	out1 error,
) {
	if err := self.shouldFail("EVMClient", "TransactionReceipt"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.TransactionReceipt(in0, in1)
	}
	return
}

// ------------------------------------------------------------------------------------------------
// SolanaClient
// ------------------------------------------------------------------------------------------------

type chaosSolanaClient struct {
	*Source
	client m24.SolanaClient
}

// If you are getting a error in this line you should probably run "make generate".
var _ m24.SolanaClient = &chaosSolanaClient{}

func (source *Source) WrapSolanaClient(client m24.SolanaClient) *chaosSolanaClient {
	return &chaosSolanaClient{Source: source, client: client}
}

func (self *chaosSolanaClient) GetAccountInfo(
	in0 m2.Context,
	in1 m25.PublicKey,
) (
	out0 *m26.GetAccountInfoResult,
	out1 error,
) {
	if err := self.shouldFail("SolanaClient", "GetAccountInfo"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetAccountInfo(in0, in1)
	}
	return
}

func (self *chaosSolanaClient) GetAccountInfoWithOpts(
	in0 m2.Context,
	in1 m25.PublicKey,
	in2 *m26.GetAccountInfoOpts,
) (
	out0 *m26.GetAccountInfoResult,
	out1 error,
) {
	if err := self.shouldFail("SolanaClient", "GetAccountInfoWithOpts"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetAccountInfoWithOpts(in0, in1, in2)
	}
	return
}

func (self *chaosSolanaClient) GetBalance(
	in0 m2.Context,
	in1 m25.PublicKey,
	in2 m26.CommitmentType,
) (
	out0 *m26.GetBalanceResult,
	out1 error,
) {
	if err := self.shouldFail("SolanaClient", "GetBalance"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetBalance(in0, in1, in2)
	}
	return
}

func (self *chaosSolanaClient) GetBlockTime(
	in0 m2.Context,
	in1 uint64,
) (
	out0 *m25.UnixTimeSeconds,
	out1 error,
) {
	if err := self.shouldFail("SolanaClient", "GetBlockTime"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetBlockTime(in0, in1)
	}
	return
}

func (self *chaosSolanaClient) GetConfirmedTransactionWithOpts(
	in0 m2.Context,
	in1 m25.Signature,
	in2 *m26.GetTransactionOpts,
) (
	out0 *m26.TransactionWithMeta,
	out1 error,
) {
	if err := self.shouldFail("SolanaClient", "GetConfirmedTransactionWithOpts"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetConfirmedTransactionWithOpts(in0, in1, in2)
	}
	return
}

func (self *chaosSolanaClient) GetHealth(
	in0 m2.Context,
) (
	out0 string,
	out1 error,
) {
	if err := self.shouldFail("SolanaClient", "GetHealth"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetHealth(in0)
	}
	return
}

func (self *chaosSolanaClient) GetLatestBlockhash(
	in0 m2.Context,
	in1 m26.CommitmentType,
) (
	out0 *m26.GetLatestBlockhashResult,
	out1 error,
) {
	if err := self.shouldFail("SolanaClient", "GetLatestBlockhash"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetLatestBlockhash(in0, in1)
	}
	return
}

func (self *chaosSolanaClient) GetRecentPrioritizationFees(
	in0 m2.Context,
	in1 m25.PublicKeySlice,
) (
	out0 []m26.PriorizationFeeResult,
	out1 error,
) {
	if err := self.shouldFail("SolanaClient", "GetRecentPrioritizationFees"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetRecentPrioritizationFees(in0, in1)
	}
	return
}

func (self *chaosSolanaClient) GetSignaturesForAddressWithOpts(
	in0 m2.Context,
	in1 m25.PublicKey,
	in2 *m26.GetSignaturesForAddressOpts,
) (
	out0 []*m26.TransactionSignature,
	out1 error,
) {
	if err := self.shouldFail("SolanaClient", "GetSignaturesForAddressWithOpts"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetSignaturesForAddressWithOpts(in0, in1, in2)
	}
	return
}

func (self *chaosSolanaClient) GetSlot(
	in0 m2.Context,
	in1 m26.CommitmentType,
) (
	out0 uint64,
	out1 error,
) {
	if err := self.shouldFail("SolanaClient", "GetSlot"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetSlot(in0, in1)
	}
	return
}

func (self *chaosSolanaClient) GetTransaction(
	in0 m2.Context,
	in1 m25.Signature,
	in2 *m26.GetTransactionOpts,
) (
	out0 *m26.GetTransactionResult,
	out1 error,
) {
	if err := self.shouldFail("SolanaClient", "GetTransaction"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetTransaction(in0, in1, in2)
	}
	return
}

func (self *chaosSolanaClient) GetVersion(
	in0 m2.Context,
) (
	out0 *m26.GetVersionResult,
	out1 error,
) {
	if err := self.shouldFail("SolanaClient", "GetVersion"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetVersion(in0)
	}
	return
}

func (self *chaosSolanaClient) SendTransactionWithOpts(
	in0 m2.Context,
	in1 *m25.Transaction,
	in2 m26.TransactionOpts,
) (
	out0 m25.Signature,
	out1 error,
) {
	if err := self.shouldFail("SolanaClient", "SendTransactionWithOpts"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.SendTransactionWithOpts(in0, in1, in2)
	}
	return
}

// ------------------------------------------------------------------------------------------------
// SuiClient
// ------------------------------------------------------------------------------------------------

type chaosSuiClient struct {
	*Source
	client m27.SuiClient
}

// If you are getting a error in this line you should probably run "make generate".
var _ m27.SuiClient = &chaosSuiClient{}

func (source *Source) WrapSuiClient(client m27.SuiClient) *chaosSuiClient {
	return &chaosSuiClient{Source: source, client: client}
}

func (self *chaosSuiClient) GetLatestCheckpoint(
	in0 m2.Context,
) (
	out0 m28.CheckpointResponse,
	out1 error,
) {
	if err := self.shouldFail("SuiClient", "GetLatestCheckpoint"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetLatestCheckpoint(in0)
	}
	return
}

func (self *chaosSuiClient) GetObjectParsedData(
	in0 m2.Context,
	in1 string,
) (
	out0 m28.SuiParsedData,
	out1 error,
) {
	if err := self.shouldFail("SuiClient", "GetObjectParsedData"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetObjectParsedData(in0, in1)
	}
	return
}

func (self *chaosSuiClient) GetOwnedObjectID(
	in0 m2.Context,
	in1 string,
	in2 string,
) (
	out0 string,
	out1 error,
) {
	if err := self.shouldFail("SuiClient", "GetOwnedObjectID"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetOwnedObjectID(in0, in1, in2)
	}
	return
}

func (self *chaosSuiClient) GetSuiCoinObjectRefs(
	in0 m2.Context,
	in1 string,
	in2 uint64,
) (
	out0 []*m29.ObjectRef,
	out1 error,
) {
	if err := self.shouldFail("SuiClient", "GetSuiCoinObjectRefs"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetSuiCoinObjectRefs(in0, in1, in2)
	}
	return
}

func (self *chaosSuiClient) HealthCheck(
	in0 m2.Context,
) (
	out0 m18.Time,
	out1 error,
) {
	if err := self.shouldFail("SuiClient", "HealthCheck"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.HealthCheck(in0)
	}
	return
}

func (self *chaosSuiClient) InspectTransactionBlock(
	in0 m2.Context,
	in1 m28.SuiDevInspectTransactionBlockRequest,
) (
	out0 m28.SuiTransactionBlockResponse,
	out1 error,
) {
	if err := self.shouldFail("SuiClient", "InspectTransactionBlock"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.InspectTransactionBlock(in0, in1)
	}
	return
}

func (self *chaosSuiClient) MoveCall(
	in0 m2.Context,
	in1 m28.MoveCallRequest,
) (
	out0 m28.TxnMetaData,
	out1 error,
) {
	if err := self.shouldFail("SuiClient", "MoveCall"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.MoveCall(in0, in1)
	}
	return
}

func (self *chaosSuiClient) QueryModuleEvents(
	in0 m2.Context,
	in1 m30.EventQuery,
) (
	out0 []m28.SuiEventResponse,
	out1 string,
	out2 error,
) {
	if err := self.shouldFail("SuiClient", "QueryModuleEvents"); err != nil {
		out2 = err
	} else {
		out0, out1, out2 = self.client.QueryModuleEvents(in0, in1)
	}
	return
}

func (self *chaosSuiClient) SuiExecuteTransactionBlock(
	in0 m2.Context,
	in1 m28.SuiExecuteTransactionBlockRequest,
) (
	out0 m28.SuiTransactionBlockResponse,
	out1 error,
) {
	if err := self.shouldFail("SuiClient", "SuiExecuteTransactionBlock"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.SuiExecuteTransactionBlock(in0, in1)
	}
	return
}

func (self *chaosSuiClient) SuiGetTransactionBlock(
	in0 m2.Context,
	in1 m28.SuiGetTransactionBlockRequest,
) (
	out0 m28.SuiTransactionBlockResponse,
	out1 error,
) {
	if err := self.shouldFail("SuiClient", "SuiGetTransactionBlock"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.SuiGetTransactionBlock(in0, in1)
	}
	return
}

func (self *chaosSuiClient) SuiMultiGetObjects(
	in0 m2.Context,
	in1 m28.SuiMultiGetObjectsRequest,
) (
	out0 []*m28.SuiObjectResponse,
	out1 error,
) {
	if err := self.shouldFail("SuiClient", "SuiMultiGetObjects"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.SuiMultiGetObjects(in0, in1)
	}
	return
}

func (self *chaosSuiClient) SuiXGetDynamicFieldObject(
	in0 m2.Context,
	in1 m28.SuiXGetDynamicFieldObjectRequest,
) (
	out0 m28.SuiObjectResponse,
	out1 error,
) {
	if err := self.shouldFail("SuiClient", "SuiXGetDynamicFieldObject"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.SuiXGetDynamicFieldObject(in0, in1)
	}
	return
}

func (self *chaosSuiClient) SuiXGetLatestSuiSystemState(
	in0 m2.Context,
) (
	out0 m28.SuiSystemStateSummary,
	out1 error,
) {
	if err := self.shouldFail("SuiClient", "SuiXGetLatestSuiSystemState"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.SuiXGetLatestSuiSystemState(in0)
	}
	return
}

func (self *chaosSuiClient) SuiXGetReferenceGasPrice(
	in0 m2.Context,
) (
	out0 uint64,
	out1 error,
) {
	if err := self.shouldFail("SuiClient", "SuiXGetReferenceGasPrice"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.SuiXGetReferenceGasPrice(in0)
	}
	return
}

// ------------------------------------------------------------------------------------------------
// TONClient
// ------------------------------------------------------------------------------------------------

type chaosTONClient struct {
	*Source
	client m31.TONClient
}

// If you are getting a error in this line you should probably run "make generate".
var _ m31.TONClient = &chaosTONClient{}

func (source *Source) WrapTONClient(client m31.TONClient) *chaosTONClient {
	return &chaosTONClient{Source: source, client: client}
}

func (self *chaosTONClient) GetAccountState(
	in0 m2.Context,
	in1 m32.AccountID,
) (
	out0 m33.Account,
	out1 error,
) {
	if err := self.shouldFail("TONClient", "GetAccountState"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetAccountState(in0, in1)
	}
	return
}

func (self *chaosTONClient) GetBlockHeader(
	in0 m2.Context,
	in1 m33.BlockIDExt,
) (
	out0 m33.BlockHeader,
	out1 error,
) {
	if err := self.shouldFail("TONClient", "GetBlockHeader"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetBlockHeader(in0, in1)
	}
	return
}

func (self *chaosTONClient) GetConfigParam(
	in0 m2.Context,
	in1 uint32,
) (
	out0 *m34.Cell,
	out1 error,
) {
	if err := self.shouldFail("TONClient", "GetConfigParam"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetConfigParam(in0, in1)
	}
	return
}

func (self *chaosTONClient) GetMasterchainInfo(
	in0 m2.Context,
) (
	out0 m33.MasterchainInfo,
	out1 error,
) {
	if err := self.shouldFail("TONClient", "GetMasterchainInfo"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetMasterchainInfo(in0)
	}
	return
}

func (self *chaosTONClient) GetTransaction(
	in0 m2.Context,
	in1 m32.AccountID,
	in2 uint64,
	in3 m32.Bits256,
) (
	out0 m32.Transaction,
	out1 error,
) {
	if err := self.shouldFail("TONClient", "GetTransaction"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetTransaction(in0, in1, in2, in3)
	}
	return
}

func (self *chaosTONClient) GetTransactions(
	in0 m2.Context,
	in1 uint32,
	in2 m32.AccountID,
	in3 uint64,
	in4 m32.Bits256,
) (
	out0 []m32.Transaction,
	out1 error,
) {
	if err := self.shouldFail("TONClient", "GetTransactions"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetTransactions(in0, in1, in2, in3, in4)
	}
	return
}

func (self *chaosTONClient) GetTransactionsSince(
	in0 m2.Context,
	in1 m32.AccountID,
	in2 uint64,
	in3 m32.Bits256,
) (
	out0 []m32.Transaction,
	out1 error,
) {
	if err := self.shouldFail("TONClient", "GetTransactionsSince"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.GetTransactionsSince(in0, in1, in2, in3)
	}
	return
}

func (self *chaosTONClient) HealthCheck(
	in0 m2.Context,
) (
	out0 m18.Time,
	out1 error,
) {
	if err := self.shouldFail("TONClient", "HealthCheck"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.HealthCheck(in0)
	}
	return
}

func (self *chaosTONClient) SendMessage(
	in0 m2.Context,
	in1 []uint8,
) (
	out0 uint32,
	out1 error,
) {
	if err := self.shouldFail("TONClient", "SendMessage"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.SendMessage(in0, in1)
	}
	return
}

// ------------------------------------------------------------------------------------------------
// TSSClient
// ------------------------------------------------------------------------------------------------

type chaosTSSClient struct {
	*Source
	client m35.TSSClient
}

// If you are getting a error in this line you should probably run "make generate".
var _ m35.TSSClient = &chaosTSSClient{}

func (source *Source) WrapTSSClient(client m35.TSSClient) *chaosTSSClient {
	return &chaosTSSClient{Source: source, client: client}
}

func (self *chaosTSSClient) IsSignatureCached(
	in0 int64,
	in1 [][]uint8,
) (
	out0 bool,
) {
	// Functions that do not return errors cannot fail.
	return self.client.IsSignatureCached(in0, in1)
}

func (self *chaosTSSClient) PubKey() (
	out0 m36.PubKey,
) {
	// Functions that do not return errors cannot fail.
	return self.client.PubKey()
}

func (self *chaosTSSClient) Sign(
	in0 m2.Context,
	in1 []uint8,
	in2 uint64,
	in3 uint64,
	in4 int64,
) (
	out0 [65]uint8,
	out1 error,
) {
	if err := self.shouldFail("TSSClient", "Sign"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.Sign(in0, in1, in2, in3, in4)
	}
	return
}

func (self *chaosTSSClient) SignBatch(
	in0 m2.Context,
	in1 [][]uint8,
	in2 uint64,
	in3 uint64,
	in4 int64,
) (
	out0 [][65]uint8,
	out1 error,
) {
	if err := self.shouldFail("TSSClient", "SignBatch"); err != nil {
		out1 = err
	} else {
		out0, out1 = self.client.SignBatch(in0, in1, in2, in3, in4)
	}
	return
}
