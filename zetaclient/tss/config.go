package tss

import (
	"encoding/json"
	"os"
	"path/filepath"
	"strings"

	"github.com/bnb-chain/tss-lib/ecdsa/keygen"
	"github.com/multiformats/go-multiaddr"
	"github.com/pkg/errors"
	"github.com/rs/zerolog"
	tsscommon "github.com/zeta-chain/go-tss/common"
	"github.com/zeta-chain/go-tss/messages"
)

const (
	// Port is the default port for go-tss server.
	Port    = 6668
	Version = messages.VersionJoinPartyWithLeader
	Algo    = tsscommon.ECDSA
)

// MultiAddressFromString parses a string into a slice of addresses (for convenience).
func MultiAddressFromString(peer string) ([]multiaddr.Multiaddr, error) {
	if peer == "" {
		return nil, errors.New("peer is empty")
	}

	ma, err := multiaddr.NewMultiaddr(peer)
	if err != nil {
		return nil, err
	}

	return []multiaddr.Multiaddr{ma}, nil
}

// ResolvePreParamsFromPath resolves TSS pre-params from json config by path.
// Error indicates that the pre-params file is not found or invalid.
// FYI: pre-params are generated by keygen.GeneratePreParams.
func ResolvePreParamsFromPath(path string) (*keygen.LocalPreParams, error) {
	if path == "" {
		return nil, errors.New("pre-params path is empty")
	}

	path = filepath.Clean(path)

	raw, err := os.ReadFile(path)
	if err != nil {
		return nil, errors.Wrapf(err, "unable to read pre-params at %q", path)
	}

	var pp keygen.LocalPreParams
	if err = json.Unmarshal(raw, &pp); err != nil {
		return nil, errors.Wrapf(err, "unable to decode pre-params at %q", path)
	}

	return &pp, nil
}

// ParsePubKeysFromPath extracts public keys from tss directory.
// Example: `tssPath="~/.tss"`. Contents:
// localstate-zetapub1addwnpepq2fdhcmfyv07s86djjca835l4f2n2ta0c7le6vnl508mseca2s9g6slj0gm.json
// Output: `zetapub1addwnpepq2fdhcmfyv07s86djjca835l4f2n2ta0c7le6vnl508mseca2s9g6slj0gm`
func ParsePubKeysFromPath(logger zerolog.Logger, tssPath string) ([]PubKey, error) {
	const prefix = "localstate-"

	files, err := os.ReadDir(tssPath)
	if err != nil {
		return nil, errors.Wrap(err, "unable to read dir")
	}

	var shareFiles []os.DirEntry
	for _, file := range files {
		if !file.IsDir() && strings.HasPrefix(filepath.Base(file.Name()), prefix) {
			shareFiles = append(shareFiles, file)
		}
	}

	if len(shareFiles) == 0 {
		logger.Warn().Msg("found no TSS key share files")
		return nil, nil
	}

	logger.Info().
		Int("count", len(shareFiles)).
		Msg("found TSS key share files")

	result := []PubKey{}
	for _, entry := range shareFiles {
		filename := filepath.Base(entry.Name())

		if !strings.HasPrefix(filename, prefix) {
			logger.Warn().
				Str("file", filename).
				Str("expected_prefix", prefix).
				Msg("skipping file: does not have the expected prefix")
			continue
		}

		if !strings.HasSuffix(filename, ".json") {
			logger.Warn().
				Str("file", filename).
				Msg("skipping file: not a JSON file")
			continue
		}

		bech32 := strings.TrimSuffix(strings.TrimPrefix(filename, prefix), ".json")

		pubKey, err := NewPubKeyFromBech32(bech32)
		if err != nil {
			logger.Error().
				Err(err).
				Str("file", filename).
				Str("bech32", bech32).
				Msg("skipping file: unable to create PubKey")
			continue
		}

		result = append(result, pubKey)
	}

	if len(result) == 0 {
		logger.Warn().Msg("found no valid TSS pub keys")
		return nil, nil
	}

	return result, nil
}
