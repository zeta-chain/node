// Code generated by mockery v2.38.0. DO NOT EDIT.

package mocks

import (
	blame "github.com/zeta-chain/go-tss/blame"
	chains "github.com/zeta-chain/zetacore/pkg/chains"

	context "context"

	interfaces "github.com/zeta-chain/zetacore/zetaclient/chains/interfaces"

	keysinterfaces "github.com/zeta-chain/zetacore/zetaclient/keys/interfaces"

	lightclienttypes "github.com/zeta-chain/zetacore/x/lightclient/types"

	math "cosmossdk.io/math"

	mock "github.com/stretchr/testify/mock"

	observertypes "github.com/zeta-chain/zetacore/x/observer/types"

	proofs "github.com/zeta-chain/zetacore/pkg/proofs"

	types "github.com/zeta-chain/zetacore/x/crosschain/types"

	zerolog "github.com/rs/zerolog"
)

// ZetacoreClient is an autogenerated mock type for the ZetacoreClient type
type ZetacoreClient struct {
	mock.Mock
}

// AddOutboundTracker provides a mock function with given fields: ctx, chainID, nonce, txHash, proof, blockHash, txIndex
func (_m *ZetacoreClient) AddOutboundTracker(ctx context.Context, chainID int64, nonce uint64, txHash string, proof *proofs.Proof, blockHash string, txIndex int64) (string, error) {
	ret := _m.Called(ctx, chainID, nonce, txHash, proof, blockHash, txIndex)

	if len(ret) == 0 {
		panic("no return value specified for AddOutboundTracker")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, uint64, string, *proofs.Proof, string, int64) (string, error)); ok {
		return rf(ctx, chainID, nonce, txHash, proof, blockHash, txIndex)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, uint64, string, *proofs.Proof, string, int64) string); ok {
		r0 = rf(ctx, chainID, nonce, txHash, proof, blockHash, txIndex)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, uint64, string, *proofs.Proof, string, int64) error); ok {
		r1 = rf(ctx, chainID, nonce, txHash, proof, blockHash, txIndex)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Chain provides a mock function with given fields:
func (_m *ZetacoreClient) Chain() chains.Chain {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Chain")
	}

	var r0 chains.Chain
	if rf, ok := ret.Get(0).(func() chains.Chain); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(chains.Chain)
	}

	return r0
}

// GetAllOutboundTrackerByChain provides a mock function with given fields: ctx, chainID, order
func (_m *ZetacoreClient) GetAllOutboundTrackerByChain(ctx context.Context, chainID int64, order interfaces.Order) ([]types.OutboundTracker, error) {
	ret := _m.Called(ctx, chainID, order)

	if len(ret) == 0 {
		panic("no return value specified for GetAllOutboundTrackerByChain")
	}

	var r0 []types.OutboundTracker
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, interfaces.Order) ([]types.OutboundTracker, error)); ok {
		return rf(ctx, chainID, order)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, interfaces.Order) []types.OutboundTracker); ok {
		r0 = rf(ctx, chainID, order)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.OutboundTracker)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, interfaces.Order) error); ok {
		r1 = rf(ctx, chainID, order)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBTCTSSAddress provides a mock function with given fields: ctx, chainID
func (_m *ZetacoreClient) GetBTCTSSAddress(ctx context.Context, chainID int64) (string, error) {
	ret := _m.Called(ctx, chainID)

	if len(ret) == 0 {
		panic("no return value specified for GetBTCTSSAddress")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) (string, error)); ok {
		return rf(ctx, chainID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64) string); ok {
		r0 = rf(ctx, chainID)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(ctx, chainID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockHeaderChainState provides a mock function with given fields: ctx, chainID
func (_m *ZetacoreClient) GetBlockHeaderChainState(ctx context.Context, chainID int64) (*lightclienttypes.ChainState, error) {
	ret := _m.Called(ctx, chainID)

	if len(ret) == 0 {
		panic("no return value specified for GetBlockHeaderChainState")
	}

	var r0 *lightclienttypes.ChainState
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) (*lightclienttypes.ChainState, error)); ok {
		return rf(ctx, chainID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64) *lightclienttypes.ChainState); ok {
		r0 = rf(ctx, chainID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lightclienttypes.ChainState)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(ctx, chainID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockHeight provides a mock function with given fields: ctx
func (_m *ZetacoreClient) GetBlockHeight(ctx context.Context) (int64, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetBlockHeight")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCctxByNonce provides a mock function with given fields: ctx, chainID, nonce
func (_m *ZetacoreClient) GetCctxByNonce(ctx context.Context, chainID int64, nonce uint64) (*types.CrossChainTx, error) {
	ret := _m.Called(ctx, chainID, nonce)

	if len(ret) == 0 {
		panic("no return value specified for GetCctxByNonce")
	}

	var r0 *types.CrossChainTx
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, uint64) (*types.CrossChainTx, error)); ok {
		return rf(ctx, chainID, nonce)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, uint64) *types.CrossChainTx); ok {
		r0 = rf(ctx, chainID, nonce)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.CrossChainTx)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, uint64) error); ok {
		r1 = rf(ctx, chainID, nonce)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCrosschainFlags provides a mock function with given fields: ctx
func (_m *ZetacoreClient) GetCrosschainFlags(ctx context.Context) (observertypes.CrosschainFlags, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetCrosschainFlags")
	}

	var r0 observertypes.CrosschainFlags
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (observertypes.CrosschainFlags, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) observertypes.CrosschainFlags); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(observertypes.CrosschainFlags)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetInboundTrackersForChain provides a mock function with given fields: ctx, chainID
func (_m *ZetacoreClient) GetInboundTrackersForChain(ctx context.Context, chainID int64) ([]types.InboundTracker, error) {
	ret := _m.Called(ctx, chainID)

	if len(ret) == 0 {
		panic("no return value specified for GetInboundTrackersForChain")
	}

	var r0 []types.InboundTracker
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) ([]types.InboundTracker, error)); ok {
		return rf(ctx, chainID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64) []types.InboundTracker); ok {
		r0 = rf(ctx, chainID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.InboundTracker)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(ctx, chainID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetKeyGen provides a mock function with given fields: ctx
func (_m *ZetacoreClient) GetKeyGen(ctx context.Context) (*observertypes.Keygen, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetKeyGen")
	}

	var r0 *observertypes.Keygen
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*observertypes.Keygen, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *observertypes.Keygen); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*observertypes.Keygen)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetKeys provides a mock function with given fields:
func (_m *ZetacoreClient) GetKeys() keysinterfaces.ObserverKeys {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetKeys")
	}

	var r0 keysinterfaces.ObserverKeys
	if rf, ok := ret.Get(0).(func() keysinterfaces.ObserverKeys); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(keysinterfaces.ObserverKeys)
		}
	}

	return r0
}

// GetLogger provides a mock function with given fields:
func (_m *ZetacoreClient) GetLogger() *zerolog.Logger {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetLogger")
	}

	var r0 *zerolog.Logger
	if rf, ok := ret.Get(0).(func() *zerolog.Logger); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*zerolog.Logger)
		}
	}

	return r0
}

// GetObserverList provides a mock function with given fields: ctx
func (_m *ZetacoreClient) GetObserverList(ctx context.Context) ([]string, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetObserverList")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]string, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []string); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetOutboundTracker provides a mock function with given fields: ctx, chain, nonce
func (_m *ZetacoreClient) GetOutboundTracker(ctx context.Context, chain chains.Chain, nonce uint64) (*types.OutboundTracker, error) {
	ret := _m.Called(ctx, chain, nonce)

	if len(ret) == 0 {
		panic("no return value specified for GetOutboundTracker")
	}

	var r0 *types.OutboundTracker
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, chains.Chain, uint64) (*types.OutboundTracker, error)); ok {
		return rf(ctx, chain, nonce)
	}
	if rf, ok := ret.Get(0).(func(context.Context, chains.Chain, uint64) *types.OutboundTracker); ok {
		r0 = rf(ctx, chain, nonce)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.OutboundTracker)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, chains.Chain, uint64) error); ok {
		r1 = rf(ctx, chain, nonce)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPendingNoncesByChain provides a mock function with given fields: ctx, chainID
func (_m *ZetacoreClient) GetPendingNoncesByChain(ctx context.Context, chainID int64) (observertypes.PendingNonces, error) {
	ret := _m.Called(ctx, chainID)

	if len(ret) == 0 {
		panic("no return value specified for GetPendingNoncesByChain")
	}

	var r0 observertypes.PendingNonces
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) (observertypes.PendingNonces, error)); ok {
		return rf(ctx, chainID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64) observertypes.PendingNonces); ok {
		r0 = rf(ctx, chainID)
	} else {
		r0 = ret.Get(0).(observertypes.PendingNonces)
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(ctx, chainID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRateLimiterFlags provides a mock function with given fields: ctx
func (_m *ZetacoreClient) GetRateLimiterFlags(ctx context.Context) (types.RateLimiterFlags, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetRateLimiterFlags")
	}

	var r0 types.RateLimiterFlags
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (types.RateLimiterFlags, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) types.RateLimiterFlags); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(types.RateLimiterFlags)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRateLimiterInput provides a mock function with given fields: ctx, window
func (_m *ZetacoreClient) GetRateLimiterInput(ctx context.Context, window int64) (*types.QueryRateLimiterInputResponse, error) {
	ret := _m.Called(ctx, window)

	if len(ret) == 0 {
		panic("no return value specified for GetRateLimiterInput")
	}

	var r0 *types.QueryRateLimiterInputResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) (*types.QueryRateLimiterInputResponse, error)); ok {
		return rf(ctx, window)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64) *types.QueryRateLimiterInputResponse); ok {
		r0 = rf(ctx, window)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.QueryRateLimiterInputResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(ctx, window)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetZetaHotKeyBalance provides a mock function with given fields: ctx
func (_m *ZetacoreClient) GetZetaHotKeyBalance(ctx context.Context) (math.Int, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetZetaHotKeyBalance")
	}

	var r0 math.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (math.Int, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) math.Int); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(math.Int)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPendingCCTX provides a mock function with given fields: ctx, chainID
func (_m *ZetacoreClient) ListPendingCCTX(ctx context.Context, chainID int64) ([]*types.CrossChainTx, uint64, error) {
	ret := _m.Called(ctx, chainID)

	if len(ret) == 0 {
		panic("no return value specified for ListPendingCCTX")
	}

	var r0 []*types.CrossChainTx
	var r1 uint64
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) ([]*types.CrossChainTx, uint64, error)); ok {
		return rf(ctx, chainID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64) []*types.CrossChainTx); ok {
		r0 = rf(ctx, chainID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.CrossChainTx)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64) uint64); ok {
		r1 = rf(ctx, chainID)
	} else {
		r1 = ret.Get(1).(uint64)
	}

	if rf, ok := ret.Get(2).(func(context.Context, int64) error); ok {
		r2 = rf(ctx, chainID)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ListPendingCCTXWithinRateLimit provides a mock function with given fields: ctx
func (_m *ZetacoreClient) ListPendingCCTXWithinRateLimit(ctx context.Context) (*types.QueryListPendingCctxWithinRateLimitResponse, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListPendingCCTXWithinRateLimit")
	}

	var r0 *types.QueryListPendingCctxWithinRateLimitResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*types.QueryListPendingCctxWithinRateLimitResponse, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *types.QueryListPendingCctxWithinRateLimitResponse); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.QueryListPendingCctxWithinRateLimitResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OnBeforeStop provides a mock function with given fields: callback
func (_m *ZetacoreClient) OnBeforeStop(callback func()) {
	_m.Called(callback)
}

// PostVoteBlameData provides a mock function with given fields: ctx, _a1, chainID, index
func (_m *ZetacoreClient) PostVoteBlameData(ctx context.Context, _a1 *blame.Blame, chainID int64, index string) (string, error) {
	ret := _m.Called(ctx, _a1, chainID, index)

	if len(ret) == 0 {
		panic("no return value specified for PostVoteBlameData")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *blame.Blame, int64, string) (string, error)); ok {
		return rf(ctx, _a1, chainID, index)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *blame.Blame, int64, string) string); ok {
		r0 = rf(ctx, _a1, chainID, index)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *blame.Blame, int64, string) error); ok {
		r1 = rf(ctx, _a1, chainID, index)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PostVoteBlockHeader provides a mock function with given fields: ctx, chainID, txhash, height, header
func (_m *ZetacoreClient) PostVoteBlockHeader(ctx context.Context, chainID int64, txhash []byte, height int64, header proofs.HeaderData) (string, error) {
	ret := _m.Called(ctx, chainID, txhash, height, header)

	if len(ret) == 0 {
		panic("no return value specified for PostVoteBlockHeader")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, []byte, int64, proofs.HeaderData) (string, error)); ok {
		return rf(ctx, chainID, txhash, height, header)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, []byte, int64, proofs.HeaderData) string); ok {
		r0 = rf(ctx, chainID, txhash, height, header)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, []byte, int64, proofs.HeaderData) error); ok {
		r1 = rf(ctx, chainID, txhash, height, header)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PostVoteGasPrice provides a mock function with given fields: ctx, chain, gasPrice, supply, blockNum
func (_m *ZetacoreClient) PostVoteGasPrice(ctx context.Context, chain chains.Chain, gasPrice uint64, supply string, blockNum uint64) (string, error) {
	ret := _m.Called(ctx, chain, gasPrice, supply, blockNum)

	if len(ret) == 0 {
		panic("no return value specified for PostVoteGasPrice")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, chains.Chain, uint64, string, uint64) (string, error)); ok {
		return rf(ctx, chain, gasPrice, supply, blockNum)
	}
	if rf, ok := ret.Get(0).(func(context.Context, chains.Chain, uint64, string, uint64) string); ok {
		r0 = rf(ctx, chain, gasPrice, supply, blockNum)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, chains.Chain, uint64, string, uint64) error); ok {
		r1 = rf(ctx, chain, gasPrice, supply, blockNum)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PostVoteInbound provides a mock function with given fields: ctx, gasLimit, retryGasLimit, msg
func (_m *ZetacoreClient) PostVoteInbound(ctx context.Context, gasLimit uint64, retryGasLimit uint64, msg *types.MsgVoteInbound) (string, string, error) {
	ret := _m.Called(ctx, gasLimit, retryGasLimit, msg)

	if len(ret) == 0 {
		panic("no return value specified for PostVoteInbound")
	}

	var r0 string
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, uint64, *types.MsgVoteInbound) (string, string, error)); ok {
		return rf(ctx, gasLimit, retryGasLimit, msg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, uint64, *types.MsgVoteInbound) string); ok {
		r0 = rf(ctx, gasLimit, retryGasLimit, msg)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, uint64, *types.MsgVoteInbound) string); ok {
		r1 = rf(ctx, gasLimit, retryGasLimit, msg)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, uint64, uint64, *types.MsgVoteInbound) error); ok {
		r2 = rf(ctx, gasLimit, retryGasLimit, msg)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// PostVoteOutbound provides a mock function with given fields: ctx, gasLimit, retryGasLimit, msg
func (_m *ZetacoreClient) PostVoteOutbound(ctx context.Context, gasLimit uint64, retryGasLimit uint64, msg *types.MsgVoteOutbound) (string, string, error) {
	ret := _m.Called(ctx, gasLimit, retryGasLimit, msg)

	if len(ret) == 0 {
		panic("no return value specified for PostVoteOutbound")
	}

	var r0 string
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, uint64, *types.MsgVoteOutbound) (string, string, error)); ok {
		return rf(ctx, gasLimit, retryGasLimit, msg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, uint64, *types.MsgVoteOutbound) string); ok {
		r0 = rf(ctx, gasLimit, retryGasLimit, msg)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, uint64, *types.MsgVoteOutbound) string); ok {
		r1 = rf(ctx, gasLimit, retryGasLimit, msg)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, uint64, uint64, *types.MsgVoteOutbound) error); ok {
		r2 = rf(ctx, gasLimit, retryGasLimit, msg)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Stop provides a mock function with given fields:
func (_m *ZetacoreClient) Stop() {
	_m.Called()
}

// NewZetacoreClient creates a new instance of ZetacoreClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewZetacoreClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *ZetacoreClient {
	mock := &ZetacoreClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
