// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
	blame "github.com/zeta-chain/go-tss/blame"
	chains "github.com/zeta-chain/node/pkg/chains"

	cometbfttypes "github.com/cometbft/cometbft/types"

	common "github.com/ethereum/go-ethereum/common"

	context "context"

	crosschaintypes "github.com/zeta-chain/node/x/crosschain/types"

	errors "github.com/zeta-chain/node/pkg/errors"

	fungibletypes "github.com/zeta-chain/node/x/fungible/types"

	interfaces "github.com/zeta-chain/node/zetaclient/keys/interfaces"

	math "cosmossdk.io/math"

	mock "github.com/stretchr/testify/mock"

	types "github.com/zeta-chain/node/x/observer/types"

	upgradetypes "cosmossdk.io/x/upgrade/types"
)

// ZetacoreClient is an autogenerated mock type for the ZetacoreClient type
type ZetacoreClient struct {
	mock.Mock
}

// Chain provides a mock function with no fields
func (_m *ZetacoreClient) Chain() chains.Chain {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Chain")
	}

	var r0 chains.Chain
	if rf, ok := ret.Get(0).(func() chains.Chain); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(chains.Chain)
	}

	return r0
}

// GetAdditionalChains provides a mock function with given fields: _a0
func (_m *ZetacoreClient) GetAdditionalChains(_a0 context.Context) ([]chains.Chain, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for GetAdditionalChains")
	}

	var r0 []chains.Chain
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]chains.Chain, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []chains.Chain); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]chains.Chain)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBTCTSSAddress provides a mock function with given fields: _a0, _a1
func (_m *ZetacoreClient) GetBTCTSSAddress(_a0 context.Context, _a1 int64) (string, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for GetBTCTSSAddress")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) (string, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64) string); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBallotByID provides a mock function with given fields: _a0, _a1
func (_m *ZetacoreClient) GetBallotByID(_a0 context.Context, _a1 string) (*types.QueryBallotByIdentifierResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for GetBallotByID")
	}

	var r0 *types.QueryBallotByIdentifierResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*types.QueryBallotByIdentifierResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *types.QueryBallotByIdentifierResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.QueryBallotByIdentifierResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBaseGasPrice provides a mock function with given fields: _a0
func (_m *ZetacoreClient) GetBaseGasPrice(_a0 context.Context) (int64, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for GetBaseGasPrice")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockHeight provides a mock function with given fields: _a0
func (_m *ZetacoreClient) GetBlockHeight(_a0 context.Context) (int64, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for GetBlockHeight")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCctxByHash provides a mock function with given fields: _a0, _a1
func (_m *ZetacoreClient) GetCctxByHash(_a0 context.Context, _a1 string) (*crosschaintypes.CrossChainTx, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for GetCctxByHash")
	}

	var r0 *crosschaintypes.CrossChainTx
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*crosschaintypes.CrossChainTx, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *crosschaintypes.CrossChainTx); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*crosschaintypes.CrossChainTx)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCctxByNonce provides a mock function with given fields: _a0, _a1, _a2
func (_m *ZetacoreClient) GetCctxByNonce(_a0 context.Context, _a1 int64, _a2 uint64) (*crosschaintypes.CrossChainTx, error) {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for GetCctxByNonce")
	}

	var r0 *crosschaintypes.CrossChainTx
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, uint64) (*crosschaintypes.CrossChainTx, error)); ok {
		return rf(_a0, _a1, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, uint64) *crosschaintypes.CrossChainTx); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*crosschaintypes.CrossChainTx)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, uint64) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetChainParams provides a mock function with given fields: _a0
func (_m *ZetacoreClient) GetChainParams(_a0 context.Context) ([]*types.ChainParams, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for GetChainParams")
	}

	var r0 []*types.ChainParams
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]*types.ChainParams, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []*types.ChainParams); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.ChainParams)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCrosschainFlags provides a mock function with given fields: _a0
func (_m *ZetacoreClient) GetCrosschainFlags(_a0 context.Context) (types.CrosschainFlags, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for GetCrosschainFlags")
	}

	var r0 types.CrosschainFlags
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (types.CrosschainFlags, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) types.CrosschainFlags); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(types.CrosschainFlags)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetForeignCoinsFromAsset provides a mock function with given fields: _a0, _a1, _a2
func (_m *ZetacoreClient) GetForeignCoinsFromAsset(_a0 context.Context, _a1 int64, _a2 common.Address) (fungibletypes.ForeignCoins, error) {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for GetForeignCoinsFromAsset")
	}

	var r0 fungibletypes.ForeignCoins
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, common.Address) (fungibletypes.ForeignCoins, error)); ok {
		return rf(_a0, _a1, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, common.Address) fungibletypes.ForeignCoins); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Get(0).(fungibletypes.ForeignCoins)
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, common.Address) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetInboundTrackersForChain provides a mock function with given fields: _a0, _a1
func (_m *ZetacoreClient) GetInboundTrackersForChain(_a0 context.Context, _a1 int64) ([]crosschaintypes.InboundTracker, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for GetInboundTrackersForChain")
	}

	var r0 []crosschaintypes.InboundTracker
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) ([]crosschaintypes.InboundTracker, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64) []crosschaintypes.InboundTracker); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]crosschaintypes.InboundTracker)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetKeyGen provides a mock function with given fields: _a0
func (_m *ZetacoreClient) GetKeyGen(_a0 context.Context) (types.Keygen, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for GetKeyGen")
	}

	var r0 types.Keygen
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (types.Keygen, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) types.Keygen); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(types.Keygen)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetKeys provides a mock function with no fields
func (_m *ZetacoreClient) GetKeys() interfaces.ObserverKeys {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetKeys")
	}

	var r0 interfaces.ObserverKeys
	if rf, ok := ret.Get(0).(func() interfaces.ObserverKeys); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interfaces.ObserverKeys)
		}
	}

	return r0
}

// GetNumberOfUnconfirmedTxs provides a mock function with given fields: _a0
func (_m *ZetacoreClient) GetNumberOfUnconfirmedTxs(_a0 context.Context) (int, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for GetNumberOfUnconfirmedTxs")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (int, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) int); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetObserverList provides a mock function with given fields: _a0
func (_m *ZetacoreClient) GetObserverList(_a0 context.Context) ([]string, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for GetObserverList")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]string, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []string); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetOperationalFlags provides a mock function with given fields: _a0
func (_m *ZetacoreClient) GetOperationalFlags(_a0 context.Context) (types.OperationalFlags, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for GetOperationalFlags")
	}

	var r0 types.OperationalFlags
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (types.OperationalFlags, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) types.OperationalFlags); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(types.OperationalFlags)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetOutboundTracker provides a mock function with given fields: _a0, _a1, _a2
func (_m *ZetacoreClient) GetOutboundTracker(_a0 context.Context, _a1 int64, _a2 uint64) (*crosschaintypes.OutboundTracker, error) {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for GetOutboundTracker")
	}

	var r0 *crosschaintypes.OutboundTracker
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, uint64) (*crosschaintypes.OutboundTracker, error)); ok {
		return rf(_a0, _a1, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, uint64) *crosschaintypes.OutboundTracker); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*crosschaintypes.OutboundTracker)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, uint64) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetOutboundTrackers provides a mock function with given fields: _a0, _a1
func (_m *ZetacoreClient) GetOutboundTrackers(_a0 context.Context, _a1 int64) ([]crosschaintypes.OutboundTracker, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for GetOutboundTrackers")
	}

	var r0 []crosschaintypes.OutboundTracker
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) ([]crosschaintypes.OutboundTracker, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64) []crosschaintypes.OutboundTracker); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]crosschaintypes.OutboundTracker)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPendingNoncesByChain provides a mock function with given fields: _a0, _a1
func (_m *ZetacoreClient) GetPendingNoncesByChain(_a0 context.Context, _a1 int64) (types.PendingNonces, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for GetPendingNoncesByChain")
	}

	var r0 types.PendingNonces
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) (types.PendingNonces, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64) types.PendingNonces); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(types.PendingNonces)
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRateLimiterFlags provides a mock function with given fields: _a0
func (_m *ZetacoreClient) GetRateLimiterFlags(_a0 context.Context) (crosschaintypes.RateLimiterFlags, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for GetRateLimiterFlags")
	}

	var r0 crosschaintypes.RateLimiterFlags
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (crosschaintypes.RateLimiterFlags, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) crosschaintypes.RateLimiterFlags); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(crosschaintypes.RateLimiterFlags)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRateLimiterInput provides a mock function with given fields: _a0, window
func (_m *ZetacoreClient) GetRateLimiterInput(_a0 context.Context, window int64) (*crosschaintypes.QueryRateLimiterInputResponse, error) {
	ret := _m.Called(_a0, window)

	if len(ret) == 0 {
		panic("no return value specified for GetRateLimiterInput")
	}

	var r0 *crosschaintypes.QueryRateLimiterInputResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) (*crosschaintypes.QueryRateLimiterInputResponse, error)); ok {
		return rf(_a0, window)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64) *crosschaintypes.QueryRateLimiterInputResponse); ok {
		r0 = rf(_a0, window)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*crosschaintypes.QueryRateLimiterInputResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(_a0, window)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSupportedChains provides a mock function with given fields: _a0
func (_m *ZetacoreClient) GetSupportedChains(_a0 context.Context) ([]chains.Chain, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for GetSupportedChains")
	}

	var r0 []chains.Chain
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]chains.Chain, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []chains.Chain); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]chains.Chain)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSyncStatus provides a mock function with given fields: _a0
func (_m *ZetacoreClient) GetSyncStatus(_a0 context.Context) (bool, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for GetSyncStatus")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (bool, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) bool); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTSS provides a mock function with given fields: _a0
func (_m *ZetacoreClient) GetTSS(_a0 context.Context) (types.TSS, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for GetTSS")
	}

	var r0 types.TSS
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (types.TSS, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) types.TSS); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(types.TSS)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTSSHistory provides a mock function with given fields: _a0
func (_m *ZetacoreClient) GetTSSHistory(_a0 context.Context) ([]types.TSS, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for GetTSSHistory")
	}

	var r0 []types.TSS
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]types.TSS, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []types.TSS); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.TSS)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUpgradePlan provides a mock function with given fields: _a0
func (_m *ZetacoreClient) GetUpgradePlan(_a0 context.Context) (*upgradetypes.Plan, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for GetUpgradePlan")
	}

	var r0 *upgradetypes.Plan
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*upgradetypes.Plan, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *upgradetypes.Plan); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*upgradetypes.Plan)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetZetaHotKeyBalance provides a mock function with given fields: _a0
func (_m *ZetacoreClient) GetZetaHotKeyBalance(_a0 context.Context) (math.Int, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for GetZetaHotKeyBalance")
	}

	var r0 math.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (math.Int, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) math.Int); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(math.Int)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HasVoted provides a mock function with given fields: _a0, _a1, _a2
func (_m *ZetacoreClient) HasVoted(_a0 context.Context, _a1 string, _a2 string) (bool, error) {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for HasVoted")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (bool, error)); ok {
		return rf(_a0, _a1, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) bool); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPendingCCTX provides a mock function with given fields: _a0, _a1
func (_m *ZetacoreClient) ListPendingCCTX(_a0 context.Context, _a1 chains.Chain) ([]*crosschaintypes.CrossChainTx, uint64, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for ListPendingCCTX")
	}

	var r0 []*crosschaintypes.CrossChainTx
	var r1 uint64
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, chains.Chain) ([]*crosschaintypes.CrossChainTx, uint64, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, chains.Chain) []*crosschaintypes.CrossChainTx); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*crosschaintypes.CrossChainTx)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, chains.Chain) uint64); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Get(1).(uint64)
	}

	if rf, ok := ret.Get(2).(func(context.Context, chains.Chain) error); ok {
		r2 = rf(_a0, _a1)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ListPendingCCTXWithinRateLimit provides a mock function with given fields: _a0
func (_m *ZetacoreClient) ListPendingCCTXWithinRateLimit(_a0 context.Context) (*crosschaintypes.QueryListPendingCctxWithinRateLimitResponse, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for ListPendingCCTXWithinRateLimit")
	}

	var r0 *crosschaintypes.QueryListPendingCctxWithinRateLimitResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*crosschaintypes.QueryListPendingCctxWithinRateLimitResponse, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *crosschaintypes.QueryListPendingCctxWithinRateLimitResponse); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*crosschaintypes.QueryListPendingCctxWithinRateLimitResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewBlockSubscriber provides a mock function with given fields: _a0
func (_m *ZetacoreClient) NewBlockSubscriber(_a0 context.Context) (chan cometbfttypes.EventDataNewBlock, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for NewBlockSubscriber")
	}

	var r0 chan cometbfttypes.EventDataNewBlock
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (chan cometbfttypes.EventDataNewBlock, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) chan cometbfttypes.EventDataNewBlock); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(chan cometbfttypes.EventDataNewBlock)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PostOutboundTracker provides a mock function with given fields: _a0, _a1, _a2, txHash
func (_m *ZetacoreClient) PostOutboundTracker(_a0 context.Context, _a1 int64, _a2 uint64, txHash string) (string, error) {
	ret := _m.Called(_a0, _a1, _a2, txHash)

	if len(ret) == 0 {
		panic("no return value specified for PostOutboundTracker")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, uint64, string) (string, error)); ok {
		return rf(_a0, _a1, _a2, txHash)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, uint64, string) string); ok {
		r0 = rf(_a0, _a1, _a2, txHash)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, uint64, string) error); ok {
		r1 = rf(_a0, _a1, _a2, txHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PostVoteBlameData provides a mock function with given fields: _a0, _a1, _a2, index
func (_m *ZetacoreClient) PostVoteBlameData(_a0 context.Context, _a1 *blame.Blame, _a2 int64, index string) (string, error) {
	ret := _m.Called(_a0, _a1, _a2, index)

	if len(ret) == 0 {
		panic("no return value specified for PostVoteBlameData")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *blame.Blame, int64, string) (string, error)); ok {
		return rf(_a0, _a1, _a2, index)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *blame.Blame, int64, string) string); ok {
		r0 = rf(_a0, _a1, _a2, index)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *blame.Blame, int64, string) error); ok {
		r1 = rf(_a0, _a1, _a2, index)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PostVoteGasPrice provides a mock function with given fields: _a0, _a1, gasPrice, priorityFee, blockNum
func (_m *ZetacoreClient) PostVoteGasPrice(_a0 context.Context, _a1 chains.Chain, gasPrice uint64, priorityFee uint64, blockNum uint64) (string, error) {
	ret := _m.Called(_a0, _a1, gasPrice, priorityFee, blockNum)

	if len(ret) == 0 {
		panic("no return value specified for PostVoteGasPrice")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, chains.Chain, uint64, uint64, uint64) (string, error)); ok {
		return rf(_a0, _a1, gasPrice, priorityFee, blockNum)
	}
	if rf, ok := ret.Get(0).(func(context.Context, chains.Chain, uint64, uint64, uint64) string); ok {
		r0 = rf(_a0, _a1, gasPrice, priorityFee, blockNum)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, chains.Chain, uint64, uint64, uint64) error); ok {
		r1 = rf(_a0, _a1, gasPrice, priorityFee, blockNum)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PostVoteInbound provides a mock function with given fields: _a0, gasLimit, retryGasLimit, _a3, monitorErrCh
func (_m *ZetacoreClient) PostVoteInbound(_a0 context.Context, gasLimit uint64, retryGasLimit uint64, _a3 *crosschaintypes.MsgVoteInbound, monitorErrCh chan<- errors.ErrTxMonitor) (string, string, error) {
	ret := _m.Called(_a0, gasLimit, retryGasLimit, _a3, monitorErrCh)

	if len(ret) == 0 {
		panic("no return value specified for PostVoteInbound")
	}

	var r0 string
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, uint64, *crosschaintypes.MsgVoteInbound, chan<- errors.ErrTxMonitor) (string, string, error)); ok {
		return rf(_a0, gasLimit, retryGasLimit, _a3, monitorErrCh)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, uint64, *crosschaintypes.MsgVoteInbound, chan<- errors.ErrTxMonitor) string); ok {
		r0 = rf(_a0, gasLimit, retryGasLimit, _a3, monitorErrCh)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, uint64, *crosschaintypes.MsgVoteInbound, chan<- errors.ErrTxMonitor) string); ok {
		r1 = rf(_a0, gasLimit, retryGasLimit, _a3, monitorErrCh)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, uint64, uint64, *crosschaintypes.MsgVoteInbound, chan<- errors.ErrTxMonitor) error); ok {
		r2 = rf(_a0, gasLimit, retryGasLimit, _a3, monitorErrCh)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// PostVoteOutbound provides a mock function with given fields: _a0, gasLimit, retryGasLimit, _a3
func (_m *ZetacoreClient) PostVoteOutbound(_a0 context.Context, gasLimit uint64, retryGasLimit uint64, _a3 *crosschaintypes.MsgVoteOutbound) (string, string, error) {
	ret := _m.Called(_a0, gasLimit, retryGasLimit, _a3)

	if len(ret) == 0 {
		panic("no return value specified for PostVoteOutbound")
	}

	var r0 string
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, uint64, *crosschaintypes.MsgVoteOutbound) (string, string, error)); ok {
		return rf(_a0, gasLimit, retryGasLimit, _a3)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, uint64, *crosschaintypes.MsgVoteOutbound) string); ok {
		r0 = rf(_a0, gasLimit, retryGasLimit, _a3)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, uint64, *crosschaintypes.MsgVoteOutbound) string); ok {
		r1 = rf(_a0, gasLimit, retryGasLimit, _a3)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, uint64, uint64, *crosschaintypes.MsgVoteOutbound) error); ok {
		r2 = rf(_a0, gasLimit, retryGasLimit, _a3)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// PostVoteTSS provides a mock function with given fields: _a0, tssPubKey, keyGenZetaHeight, _a3
func (_m *ZetacoreClient) PostVoteTSS(_a0 context.Context, tssPubKey string, keyGenZetaHeight int64, _a3 chains.ReceiveStatus) (string, error) {
	ret := _m.Called(_a0, tssPubKey, keyGenZetaHeight, _a3)

	if len(ret) == 0 {
		panic("no return value specified for PostVoteTSS")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, chains.ReceiveStatus) (string, error)); ok {
		return rf(_a0, tssPubKey, keyGenZetaHeight, _a3)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, chains.ReceiveStatus) string); ok {
		r0 = rf(_a0, tssPubKey, keyGenZetaHeight, _a3)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int64, chains.ReceiveStatus) error); ok {
		r1 = rf(_a0, tssPubKey, keyGenZetaHeight, _a3)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewZetacoreClient creates a new instance of ZetacoreClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewZetacoreClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *ZetacoreClient {
	mock := &ZetacoreClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
